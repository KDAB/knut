/*
  This file is part of Knut.

  SPDX-FileCopyrightText: 2024 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>

  SPDX-License-Identifier: GPL-3.0-only

  Contact KDAB at <info@kdab.com> for commercial licensing options.
*/

#include "transformation.h"
#include "predicates.h"
#include "tree.h"

#include <QObject>
#include <utility>

namespace treesitter {

Transformation::Transformation(QString source, Parser &&parser, std::shared_ptr<Query> query,
                               QString transformationTarget)
    : m_source(std::move(source))
    , m_parser(std::move(parser))
    , m_query(std::move(query))
    , m_to(std::move(transformationTarget))
{
}

QString Transformation::run()
{
    auto resultText = m_source;

    m_replacements = 0;

    QueryCursor cursor;
    bool shouldContinue;
    do {
        const auto tree = m_parser.parseString(resultText);
        if (!tree.has_value()) {
            throw Error {.description = "Unknown parser error!"};
        }
        cursor.execute(m_query, tree->rootNode(), std::make_unique<Predicates>(resultText));

        shouldContinue = runOneTransformation(cursor, resultText);
    } while (shouldContinue);

    return resultText;
}

bool Transformation::runOneTransformation(QueryCursor &cursor, QString &resultText)
{
    std::unordered_map<QString, QString> context;

    bool hasMatch = false;
    // We want to allow multiple patterns, where not every pattern
    // has a @from capture, but can provide additional context.
    // Loop over them until we find a @from capture.
    while (auto match = cursor.nextMatch()) {
        hasMatch = true;
        const auto captures = match->captures();
        for (const auto &capture : captures) {
            auto captureName = m_query->captureAt(capture.id).name;
            context[captureName] = capture.node.textIn(resultText);
        }

        const auto from = match->capturesNamed("from");
        if (!from.isEmpty()) {
            const auto fromStart = from.first().node.startPosition();
            const auto fromEnd = from.first().node.endPosition();

            QString after = m_to;
            for (const auto &[name, value] : context) {
                after.replace("@" + name, value);
            }

            resultText.replace(fromStart, fromEnd - fromStart, after);
            if (++m_replacements >= m_max_replacements) {
                throw Error {.description = QObject::tr("Maximum number of allowed transformations reached.\nPossibly "
                                                        "your transformation is recursive?")};
            }
            context = std::unordered_map<QString, QString>();
            return true;
        }
    }

    if (hasMatch && m_replacements == 0) {
        // We found at least one match, but no @from capture and didn't make any replacements before.
        throw Error {.description = QObject::tr("'@from' capture not found!")};
    }

    return false;
}

} // namespace treesitter
