/*
  This file is part of Knut.

  SPDX-FileCopyrightText: 2024 Klar√§lvdalens Datakonsult AB, a KDAB Group company <info@kdab.com>

  SPDX-License-Identifier: GPL-3.0-only

  Contact KDAB at <info@kdab.com> for commercial licensing options.
*/

// File generated by spec2cpp tool
// DO NOT MAKE ANY CHANGES HERE

#pragma once

#include "utils/json.h"

#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <variant>

namespace Lsp {

/*
A set of predefined token types. This set is not fixed
an clients can specify additional token types via the
corresponding client capabilities.

@since 3.16.0
*/
enum class SemanticTokenTypes {
    Namespace,
    /*
    Represents a generic type. Acts as a fallback for types which can't be mapped to
    a specific type like class or enum.
    */
    Type,
    Class,
    Enum,
    Interface,
    Struct,
    TypeParameter,
    Parameter,
    Variable,
    Property,
    EnumMember,
    Event,
    Function,
    Method,
    Macro,
    Keyword,
    Modifier,
    Comment,
    String,
    Number,
    Regexp,
    Operator,
    // @since 3.17.0
    Decorator,
};

/*
A set of predefined token modifiers. This set is not fixed
an clients can specify additional token types via the
corresponding client capabilities.

@since 3.16.0
*/
enum class SemanticTokenModifiers {
    Declaration,
    Definition,
    Readonly,
    Static,
    Deprecated,
    Abstract,
    Async,
    Modification,
    Documentation,
    DefaultLibrary,
};

// Predefined error codes.
enum class ErrorCodes {
    ParseError = -32700,
    InvalidRequest = -32600,
    MethodNotFound = -32601,
    InvalidParams = -32602,
    InternalError = -32603,
    /*
    This is the start range of JSON RPC reserved error codes.
    It doesn't denote a real error code. No application error codes should
    be defined between the start and end range. For backwards
    compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
    are left in the range.

    @since 3.16.0
    */
    JsonrpcReservedErrorRangeStart = -32099,
    /* @deprecated use  jsonrpcReservedErrorRangeStart */
    ServerErrorStart = -32099,
    /*
    Error code indicating that a server received a notification or
    request before the server has received the `initialize` request.
    */
    ServerNotInitialized = -32002,
    UnknownErrorCode = -32001,
    /*
    This is the end range of JSON RPC reserved error codes.
    It doesn't denote a real error code.

    @since 3.16.0
    */
    JsonrpcReservedErrorRangeEnd = -32000,
    /* @deprecated use  jsonrpcReservedErrorRangeEnd */
    ServerErrorEnd = -32000,
};

enum class LSPErrorCodes {
    /*
    This is the start range of LSP reserved error codes.
    It doesn't denote a real error code.

    @since 3.16.0
    */
    LspReservedErrorRangeStart = -32899,
    /*
    A request failed but it was syntactically correct, e.g the
    method name was known and the parameters were valid. The error
    message should contain human readable information about why
    the request failed.

    @since 3.17.0
    */
    RequestFailed = -32803,
    /*
    The server cancelled the request. This error code should
    only be used for requests that explicitly support being
    server cancellable.

    @since 3.17.0
    */
    ServerCancelled = -32802,
    /*
    The server detected that the content of a document got
    modified outside normal conditions. A server should
    NOT send this error code if it detects a content change
    in it unprocessed messages. The result even computed
    on an older state might still be useful for the client.

    If a client decides that a result is not of any use anymore
    the client should cancel the request.
    */
    ContentModified = -32801,
    /*
    The client has canceled a request and a server as detected
    the cancel.
    */
    RequestCancelled = -32800,
    /*
    This is the end range of LSP reserved error codes.
    It doesn't denote a real error code.

    @since 3.16.0
    */
    LspReservedErrorRangeEnd = -32800,
};

// A set of predefined range kinds.
enum class FoldingRangeKind {
    // Folding range for a comment
    Comment,
    // Folding range for an import or include
    Imports,
    // Folding range for a region (e.g. `#region`)
    Region,
};

// A symbol kind.
enum class SymbolKind {
    File = 1,
    Module = 2,
    Namespace = 3,
    Package = 4,
    Class = 5,
    Method = 6,
    Property = 7,
    Field = 8,
    Constructor = 9,
    Enum = 10,
    Interface = 11,
    Function = 12,
    Variable = 13,
    Constant = 14,
    String = 15,
    Number = 16,
    Boolean = 17,
    Array = 18,
    Object = 19,
    Key = 20,
    Null = 21,
    EnumMember = 22,
    Struct = 23,
    Event = 24,
    Operator = 25,
    TypeParameter = 26,
};

/*
Symbol tags are extra annotations that tweak the rendering of a symbol.

@since 3.16
*/
enum class SymbolTag {
    // Render a symbol as obsolete, usually using a strike-out.
    Deprecated = 1,
};

/*
Moniker uniqueness level to define scope of the moniker.

@since 3.16.0
*/
enum class UniquenessLevel {
    // The moniker is only unique inside a document
    Document,
    // The moniker is unique inside a project for which a dump got created
    Project,
    // The moniker is unique inside the group to which a project belongs
    Group,
    // The moniker is unique inside the moniker scheme.
    Scheme,
    // The moniker is globally unique
    Global,
};

/*
The moniker kind.

@since 3.16.0
*/
enum class MonikerKind {
    // The moniker represent a symbol that is imported into a project
    Import,
    // The moniker represents a symbol that is exported from a project
    Export,
    /*
    The moniker represents a symbol that is local to a project (e.g. a local
    variable of a function, a class not visible outside the project, ...)
    */
    Local,
};

/*
Inlay hint kinds.

@since 3.17.0
*/
enum class InlayHintKind {
    // An inlay hint that for a type annotation.
    Type = 1,
    // An inlay hint that is for a parameter.
    Parameter = 2,
};

// The message type
enum class MessageType {
    // An error message.
    Error = 1,
    // A warning message.
    Warning = 2,
    // An information message.
    Info = 3,
    // A log message.
    Log = 4,
};

/*
Defines how the host (editor) should sync
document changes to the language server.
*/
enum class TextDocumentSyncKind {
    // Documents should not be synced at all.
    None = 0,
    /*
    Documents are synced by always sending the full content
    of the document.
    */
    Full = 1,
    /*
    Documents are synced by sending the full content on open.
    After that only incremental updates to the document are
    sent.
    */
    Incremental = 2,
};

// Represents reasons why a text document is saved.
enum class TextDocumentSaveReason {
    /*
    Manually triggered, e.g. by the user pressing save, by starting debugging,
    or by an API call.
    */
    Manual = 1,
    // Automatic after a delay.
    AfterDelay = 2,
    // When the editor lost focus.
    FocusOut = 3,
};

// The kind of a completion entry.
enum class CompletionItemKind {
    Text = 1,
    Method = 2,
    Function = 3,
    Constructor = 4,
    Field = 5,
    Variable = 6,
    Class = 7,
    Interface = 8,
    Module = 9,
    Property = 10,
    Unit = 11,
    Value = 12,
    Enum = 13,
    Keyword = 14,
    Snippet = 15,
    Color = 16,
    File = 17,
    Reference = 18,
    Folder = 19,
    EnumMember = 20,
    Constant = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25,
};

/*
Completion item tags are extra annotations that tweak the rendering of a completion
item.

@since 3.15.0
*/
enum class CompletionItemTag {
    // Render a completion as obsolete, usually using a strike-out.
    Deprecated = 1,
};

/*
Defines whether the insert text in a completion item should be interpreted as
plain text or a snippet.
*/
enum class InsertTextFormat {
    // The primary text to be inserted is treated as a plain string.
    PlainText = 1,
    /*
    The primary text to be inserted is treated as a snippet.

    A snippet can define tab stops and placeholders with `$1`, `$2`
    and `${3:foo}`. `$0` defines the final tab stop, it defaults to
    the end of the snippet. Placeholders with equal identifiers are linked,
    that is typing in one will update others too.

    See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
    */
    Snippet = 2,
};

/*
How whitespace and indentation is handled during completion
item insertion.

@since 3.16.0
*/
enum class InsertTextMode {
    /*
    The insertion or replace strings is taken as it is. If the
    value is multi line the lines below the cursor will be
    inserted using the indentation defined in the string value.
    The client will not apply any kind of adjustments to the
    string.
    */
    AsIs = 1,
    /*
    The editor adjusts leading whitespace of new lines so that
    they match the indentation up to the cursor of the line for
    which the item is accepted.

    Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
    multi line completion item is indented using 2 tabs and all
    following lines inserted will be indented using 2 tabs as well.
    */
    AdjustIndentation = 2,
};

// A document highlight kind.
enum class DocumentHighlightKind {
    // A textual occurrence.
    Text = 1,
    // Read-access of a symbol, like reading a variable.
    Read = 2,
    // Write-access of a symbol, like writing to a variable.
    Write = 3,
};

// A set of predefined code action kinds
enum class CodeActionKind {
    // Empty kind.
    Empty,
    // Base kind for quickfix actions: 'quickfix'
    QuickFix,
    // Base kind for refactoring actions: 'refactor'
    Refactor,
    /*
    Base kind for refactoring extraction actions: 'refactor.extract'

    Example extract actions:

    - Extract method
    - Extract function
    - Extract variable
    - Extract interface from class
    - ...
    */
    RefactorExtract,
    /*
    Base kind for refactoring inline actions: 'refactor.inline'

    Example inline actions:

    - Inline function
    - Inline variable
    - Inline constant
    - ...
    */
    RefactorInline,
    /*
    Base kind for refactoring rewrite actions: 'refactor.rewrite'

    Example rewrite actions:

    - Convert JavaScript function to class
    - Add or remove parameter
    - Encapsulate field
    - Make method static
    - Move method to base class
    - ...
    */
    RefactorRewrite,
    /*
    Base kind for source actions: `source`

    Source code actions apply to the entire file.
    */
    Source,
    // Base kind for an organize imports source action: `source.organizeImports`
    SourceOrganizeImports,
    /*
    Base kind for auto-fix source actions: `source.fixAll`.

    Fix all actions automatically fix errors that have a clear fix that do not require user input.
    They should not suppress errors or perform unsafe fixes such as generating new types or classes.

    @since 3.15.0
    */
    SourceFixAll,
};

enum class TraceValues {
    // Turn tracing off.
    Off,
    // Trace messages only.
    Messages,
    // Verbose message tracing.
    Verbose,
};

/*
Describes the content type that a client supports in various
result literals like `Hover`, `ParameterInfo` or `CompletionItem`.

Please note that `MarkupKinds` must not start with a `$`. This kinds
are reserved for internal usage.
*/
enum class MarkupKind {
    // Plain text is supported as a content format
    PlainText,
    // Markdown is supported as a content format
    Markdown,
};

/*
A set of predefined position encoding kinds.

@since 3.17.0
*/
enum class PositionEncodingKind {
    // Character offsets count UTF-8 code units.
    UTF8,
    /*
    Character offsets count UTF-16 code units.

    This is the default and must always be supported
    by servers
    */
    UTF16,
    /*
    Character offsets count UTF-32 code units.

    Implementation note: these are the same as Unicode code points,
    so this `PositionEncodingKind` may also be used for an
    encoding-agnostic representation of character offsets.
    */
    UTF32,
};

// The file event type
enum class FileChangeType {
    // The file got created.
    Created = 1,
    // The file got changed.
    Changed = 2,
    // The file got deleted.
    Deleted = 3,
};

enum class WatchKind {
    // Interested in create events.
    Create = 1,
    // Interested in change events
    Change = 2,
    // Interested in delete events
    Delete = 4,
};

// The diagnostic's severity.
enum class DiagnosticSeverity {
    // Reports an error.
    Error = 1,
    // Reports a warning.
    Warning = 2,
    // Reports an information.
    Information = 3,
    // Reports a hint.
    Hint = 4,
};

/*
The diagnostic tags.

@since 3.15.0
*/
enum class DiagnosticTag {
    /*
    Unused or unnecessary code.

    Clients are allowed to render diagnostics with this tag faded out instead of having
    an error squiggle.
    */
    Unnecessary = 1,
    /*
    Deprecated or obsolete code.

    Clients are allowed to rendered diagnostics with this tag strike through.
    */
    Deprecated = 2,
};

// How a completion was triggered
enum class CompletionTriggerKind {
    /*
    Completion was triggered by typing an identifier (24x7 code
    complete), manual invocation (e.g Ctrl+Space) or via API.
    */
    Invoked = 1,
    /*
    Completion was triggered by a trigger character specified by
    the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
    */
    TriggerCharacter = 2,
    // Completion was re-triggered as current completion list is incomplete
    TriggerForIncompleteCompletions = 3,
};

/*
How a signature help was triggered.

@since 3.15.0
*/
enum class SignatureHelpTriggerKind {
    // Signature help was invoked manually by the user or by a command.
    Invoked = 1,
    // Signature help was triggered by a trigger character.
    TriggerCharacter = 2,
    // Signature help was triggered by the cursor moving or by the document content changing.
    ContentChange = 3,
};

/*
The reason why code actions were requested.

@since 3.17.0
*/
enum class CodeActionTriggerKind {
    // Code actions were explicitly requested by the user or by an extension.
    Invoked = 1,
    /*
    Code actions were requested automatically.

    This typically happens when current selection in a file changes, but can
    also be triggered when file content changes.
    */
    Automatic = 2,
};

/*
A pattern kind describing if a glob pattern matches a file a folder or
both.

@since 3.16.0
*/
enum class FileOperationPatternKind {
    // The pattern matches a file only.
    File,
    // The pattern matches a folder only.
    Folder,
};

/*
A notebook cell kind.

@since 3.17.0
*/
enum class NotebookCellKind {
    // A markup-cell is formatted source that is used for display.
    Markup = 1,
    // A code-cell is source code.
    Code = 2,
};

enum class ResourceOperationKind {
    // Supports creating new files and folders.
    Create,
    // Supports renaming existing files and folders.
    Rename,
    // Supports deleting existing files and folders.
    Delete,
};

enum class FailureHandlingKind {
    /*
    Applying the workspace change is simply aborted if one of the changes provided
    fails. All operations executed before the failing operation stay executed.
    */
    Abort,
    /*
    All operations are executed transactional. That means they either all
    succeed or no changes at all are applied to the workspace.
    */
    Transactional,
    /*
    If the workspace edit contains only textual file changes they are executed transactional.
    If resource changes (create, rename or delete file) are part of the change the failure
    handling strategy is abort.
    */
    TextOnlyTransactional,
    /*
    The client tries to undo the operations already executed. But there is no
    guarantee that this is succeeding.
    */
    Undo,
};

enum class PrepareSupportDefaultBehavior {
    /*
    The client's default behavior is to select the identifier
    according the to language's syntax rule.
    */
    Identifier = 1,
};

enum class TokenFormat {
    Relative,
};

// An identifier to refer to a change annotation stored with a workspace edit.
using ChangeAnnotationIdentifier = std::string;

struct HoverClientCapabilities
{
    // Whether hover supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    Client supports the following content formats for the content
    property. The order describes the preferred format of the client.
    */
    std::optional<std::vector<MarkupKind>> contentFormat;
};

/*
A tagging type for string properties that are actually URIs

@since 3.16.0
*/
using URI = std::string;

/*
LSP arrays.
@since 3.17.0
*/
using LSPArray = std::vector<nlohmann::json>;

struct WorkDoneProgressOptions
{
    std::optional<bool> workDoneProgress;
};

// The glob pattern to watch relative to the base path. Glob patterns can have the following syntax:
// - `*` to match one or more characters in a path segment
// - `?` to match on one character in a path segment
// - `**` to match any number of path segments, including none
// - `{}` to group conditions (e.g. `**‚Äã/*.{ts,js}` matches all TypeScript and JavaScript files)
// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`,
// `example.1`, ‚Ä¶)
// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on
// `example.a`, `example.b`, but not `example.0`)

// @since 3.17.0

using Pattern = std::string;

struct FoldingRange
{
    /*
    The zero-based start line of the range to fold. The folded area starts after the line's last character.
    To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    */
    unsigned int startLine;
    // The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the
    // start line.
    std::optional<unsigned int> startCharacter;
    /*
    The zero-based end line of the range to fold. The folded area ends with the line's last character.
    To be valid, the end must be zero or larger and smaller than the number of lines in the document.
    */
    unsigned int endLine;
    // The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end
    // line.
    std::optional<unsigned int> endCharacter;
    /*
    Describes the kind of the folding range such as `comment' or 'region'. The kind
    is used to categorize folding ranges and used by commands like 'Fold all comments'.
    See [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds.
    */
    std::optional<FoldingRangeKind> kind;
    /*
    The text that the client should show when the specified range is
    collapsed. If not defined or not supported by the client, a default
    will be chosen by the client.

    @since 3.17.0
    */
    std::optional<std::string> collapsedText;
};

using ProgressToken = std::variant<int, std::string>;

struct SemanticTokensPartialResult
{
    std::vector<unsigned int> data;
};

struct Moniker
{
    // The scheme of the moniker. For example tsc or .Net
    std::string scheme;
    /*
    The identifier of the moniker. The value is opaque in LSIF however
    schema owners are allowed to define the structure if they want.
    */
    std::string identifier;
    // The scope in which the moniker is unique
    UniquenessLevel unique;
    // The moniker kind if known.
    std::optional<MonikerKind> kind;
};

struct LogMessageParams
{
    // The message type. See {@link MessageType}
    MessageType type;
    // The actual message.
    std::string message;
};

struct SemanticTokens
{
    /*
    An optional result id. If provided and clients support delta updating
    the client will include the result id in the next semantic token request.
    A server can then instead of computing all semantic tokens again simply
    send a delta.
    */
    std::optional<std::string> resultId;
    // The actual tokens.
    std::vector<unsigned int> data;
};

struct ShowDocumentResult
{
    // A boolean indicating if the show was successful.
    bool success;
};

using DocumentUri = std::string;

struct DiagnosticServerCancellationData
{
    bool retriggerRequest;
};

struct MessageActionItem
{
    // A short title like 'Retry', 'Open Log' etc.
    std::string title;
};

struct ShowMessageParams
{
    // The message type. See {@link MessageType}
    MessageType type;
    // The actual message.
    std::string message;
};

struct DidChangeConfigurationParams
{
    // The actual changed settings
    nlohmann::json settings;
};

struct InitializedParams
{
};

struct InitializeError
{
    /*
    Indicates whether the client execute the following retry logic:
    (1) show the message provided by the ResponseError to the user
    (2) user selects retry or cancel
    (3) if user selected retry the initialize method is sent again.
    */
    bool retry;
};

struct DidChangeConfigurationRegistrationOptions
{
    std::optional<std::variant<std::string, std::vector<std::string>>> section;
};

struct CancelParams
{
    // The request id to cancel.
    std::variant<int, std::string> id;
};

struct Command
{
    // Title of the command, like `save`.
    std::string title;
    // The identifier of the actual command handler.
    std::string command;
    /*
    Arguments that the command handler should be
    invoked with.
    */
    std::optional<std::vector<nlohmann::json>> arguments;
};

struct WorkDoneProgressBegin
{
    static inline const std::string kind = "begin";
    /*
    Mandatory title of the progress operation. Used to briefly inform about
    the kind of operation being performed.

    Examples: "Indexing" or "Linking dependencies".
    */
    std::string title;
    /*
    Controls if a cancel button should show to allow the user to cancel the
    long running operation. Clients that don't support cancellation are allowed
    to ignore the setting.
    */
    std::optional<bool> cancellable;
    /*
    Optional, more detailed associated progress message. Contains
    complementary information to the `title`.

    Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
    If unset, the previous progress message (if any) is still valid.
    */
    std::optional<std::string> message;
    /*
    Optional progress percentage to display (value 100 is considered 100%).
    If not provided infinite progress is assumed and clients are allowed
    to ignore the `percentage` value in subsequent in report notifications.

    The value should be steadily rising. Clients are free to ignore values
    that are not following this rule. The value range is [0, 100].
    */
    std::optional<unsigned int> percentage;
};

struct UnchangedDocumentDiagnosticReport
{
    /*
    A document diagnostic report indicating
    no changes to the last result. A server can
    only return `unchanged` if result ids are
    provided.
    */
    static inline const std::string kind = "unchanged";
    /*
    A result id which will be sent on the next
    diagnostic request for the same document.
    */
    std::string resultId;
};

struct LogTraceParams
{
    std::string message;
    std::optional<std::string> verbose;
};

struct SetTraceParams
{
    TraceValues value;
};

struct WorkDoneProgressEnd
{
    static inline const std::string kind = "end";
    /*
    Optional, a final message indicating to for example indicate the outcome
    of the operation.
    */
    std::optional<std::string> message;
};

struct WorkDoneProgressReport
{
    static inline const std::string kind = "report";
    /*
    Controls enablement state of a cancel button.

    Clients that don't support cancellation or don't support controlling the button's
    enablement state are allowed to ignore the property.
    */
    std::optional<bool> cancellable;
    /*
    Optional, more detailed associated progress message. Contains
    complementary information to the `title`.

    Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
    If unset, the previous progress message (if any) is still valid.
    */
    std::optional<std::string> message;
    /*
    Optional progress percentage to display (value 100 is considered 100%).
    If not provided infinite progress is assumed and clients are allowed
    to ignore the `percentage` value in subsequent in report notifications.

    The value should be steadily rising. Clients are free to ignore values
    that are not following this rule. The value range is [0, 100]
    */
    std::optional<unsigned int> percentage;
};

struct ApplyWorkspaceEditResult
{
    // Indicates whether the edit was applied or not.
    bool applied;
    /*
    An optional textual description for why the edit was not applied.
    This may be used by the server for diagnostic logging or to provide
    a suitable error for a request that triggered the edit.
    */
    std::optional<std::string> failureReason;
    /*
    Depending on the client's failure handling strategy `failedChange` might
    contain the index of the change that failed. This property is only available
    if the client signals a `failureHandlingStrategy` in its client capabilities.
    */
    std::optional<unsigned int> failedChange;
};

struct NotebookDocumentFilter_3
{
    /* The type of the enclosing notebook. */
    std::optional<std::string> notebookType;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`. */
    std::optional<std::string> scheme;
    /* A glob pattern. */
    std::string pattern;
};

struct SemanticTokensEdit
{
    // The start offset of the edit.
    unsigned int start;
    // The count of elements to remove.
    unsigned int deleteCount;
    // The elements to insert.
    std::optional<std::vector<unsigned int>> data;
};

struct Position
{
    /*
    Line position in a document (zero-based).

    If a line number is greater than the number of lines in a document, it defaults back to the number of lines in the
    document. If a line number is negative, it defaults to 0.
    */
    unsigned int line;
    /*
    Character offset on a line in a document (zero-based).

    The meaning of this offset is determined by the negotiated
    `PositionEncodingKind`.

    If the character value is greater than the line length it defaults back to the
    line length.
    */
    unsigned int character;
};

struct FileCreate
{
    // A file:// URI for the location of the file/folder being created.
    std::string uri;
};

struct TextDocumentIdentifier
{
    // The text document's uri.
    DocumentUri uri;
};

struct ConfigurationItem
{
    // The scope to get the configuration section for.
    std::optional<std::string> scopeUri;
    // The configuration section asked for.
    std::optional<std::string> section;
};

struct LinkedEditingRangeClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

struct MarkupContent
{
    // The type of the Markup
    MarkupKind kind;
    // The content itself
    std::string value;
};

struct StaticRegistrationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct FileDelete
{
    // A file:// URI for the location of the file/folder being deleted.
    std::string uri;
};

struct FileRename
{
    // A file:// URI for the original location of the file/folder being renamed.
    std::string oldUri;
    // A file:// URI for the new location of the file/folder being renamed.
    std::string newUri;
};

struct ChangeAnnotation
{
    /*
    A human-readable string describing the actual change. The string
    is rendered prominent in the user interface.
    */
    std::string label;
    /*
    A flag which indicates that user confirmation is needed
    before applying the change.
    */
    std::optional<bool> needsConfirmation;
    /*
    A human-readable string which is rendered less prominent in
    the user interface.
    */
    std::optional<std::string> description;
};

struct CompletionItemLabelDetails
{
    /*
    An optional string which is rendered less prominently directly after {@link CompletionItem.label label},
    without any spacing. Should be used for function signatures and type annotations.
    */
    std::optional<std::string> detail;
    /*
    An optional string which is rendered less prominently after {@link CompletionItem.detail}. Should be used
    for fully qualified names and file paths.
    */
    std::optional<std::string> description;
};

struct CompletionContext
{
    // How the completion was triggered.
    CompletionTriggerKind triggerKind;
    /*
    The trigger character (a single character) that has trigger code complete.
    Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
    */
    std::optional<std::string> triggerCharacter;
};

struct ReferenceContext
{
    // Include the declaration of the current symbol.
    bool includeDeclaration;
};

struct FileEvent
{
    // The file's uri.
    DocumentUri uri;
    // The change type.
    FileChangeType type;
};

struct SaveOptions
{
    // The client is supposed to include the content on save.
    std::optional<bool> includeText;
};

struct Unregistration
{
    /*
    The id used to unregister the request or notification. Usually an id
    provided during the register request.
    */
    std::string id;
    // The method to unregister for.
    std::string method;
};

struct Registration
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again.
    */
    std::string id;
    // The method / capability to register for.
    std::string method;
    // Options necessary for the registration.
    std::optional<nlohmann::json> registerOptions;
};

struct FormattingOptions
{
    // Size of a tab in spaces.
    unsigned int tabSize;
    // Prefer spaces over tabs.
    bool insertSpaces;
    /*
    Trim trailing whitespace on a line.

    @since 3.15.0
    */
    std::optional<bool> trimTrailingWhitespace;
    /*
    Insert a newline character at the end of the file if one does not exist.

    @since 3.15.0
    */
    std::optional<bool> insertFinalNewline;
    /*
    Trim all newlines after the final newline at the end of the file.

    @since 3.15.0
    */
    std::optional<bool> trimFinalNewlines;
    std::map<std::string, std::variant<bool, int, std::string>> propertyMap;
};

struct TextDocumentItem
{
    // The text document's uri.
    DocumentUri uri;
    // The text document's language identifier.
    std::string languageId;
    /*
    The version number of this document (it will increase after each
    change, including undo/redo).
    */
    int version;
    // The content of the opened text document.
    std::string text;
};

struct PreviousResultId
{
    /*
    The URI for which the client knows a
    result id.
    */
    DocumentUri uri;
    // The value of the previous result id.
    std::string value;
};

struct Color
{
    // The red component of this color in the range [0-1].
    float red;
    // The green component of this color in the range [0-1].
    float green;
    // The blue component of this color in the range [0-1].
    float blue;
    // The alpha component of this color in the range [0-1].
    float alpha;
};

struct DocumentOnTypeFormattingOptions
{
    // A character on which formatting should be triggered, like `{`.
    std::string firstTriggerCharacter;
    // More trigger characters.
    std::optional<std::vector<std::string>> moreTriggerCharacter;
};

struct BaseSymbolInformation
{
    // The name of this symbol.
    std::string name;
    // The kind of this symbol.
    SymbolKind kind;
    /*
    Tags for this symbol.

    @since 3.16.0
    */
    std::optional<std::vector<SymbolTag>> tags;
    /*
    The name of the symbol containing this symbol. This information is for
    user interface purposes (e.g. to render a qualifier in the user interface
    if necessary). It can't be used to re-infer a hierarchy for the document
    symbols.
    */
    std::optional<std::string> containerName;
};

struct FileOperationPatternOptions
{
    // The pattern should be matched ignoring casing.
    std::optional<bool> ignoreCase;
};

struct WorkspaceFoldersServerCapabilities
{
    // The server has support for workspace folders
    std::optional<bool> supported;
    /*
    Whether the server wants to receive workspace folder
    change notifications.

    If a string is provided the string is treated as an ID
    under which the notification is registered on the client
    side. The ID can be used to unregister for these events
    using the `client/unregisterCapability` request.
    */
    std::optional<std::variant<std::string, bool>> changeNotifications;
};

struct InlineValueWorkspaceClientCapabilities
{
    /*
    Whether the client implementation supports a refresh request sent from the
    server to the client.

    Note that this event is global and will force the client to refresh all
    inline values currently shown. It should be used with absolute care and is
    useful for situation where a server for example detects a project wide
    change that requires such a calculation.
    */
    std::optional<bool> refreshSupport;
};

struct RenameFileOptions
{
    // Overwrite target if existing. Overwrite wins over `ignoreIfExists`
    std::optional<bool> overwrite;
    // Ignores if target exists.
    std::optional<bool> ignoreIfExists;
};

struct CreateFileOptions
{
    // Overwrite existing file. Overwrite wins over `ignoreIfExists`
    std::optional<bool> overwrite;
    // Ignore if exists.
    std::optional<bool> ignoreIfExists;
};

struct WorkspaceSymbolClientCapabilities
{
    struct SymbolKindType
    {
        /*
        The symbol kind values the client supports. When this
        property exists the client also guarantees that it will
        handle values outside its set gracefully and falls back
        to a default value when unknown.

        If this property is not present the client only supports
        the symbol kinds from `File` to `Array` as defined in
        the initial version of the protocol.
        */
        std::optional<std::vector<SymbolKind>> valueSet;
    };
    struct TagSupportType
    {
        // The tags supported by the client.
        std::vector<SymbolTag> valueSet;
    };
    struct ResolveSupportType
    {
        /*
        The properties that a client can resolve lazily. Usually
        `location.range`
        */
        std::vector<std::string> properties;
    };
    // Symbol request supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    // Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
    std::optional<SymbolKindType> symbolKind;
    /*
    The client supports tags on `SymbolInformation`.
    Clients supporting tags have to handle unknown tags gracefully.

    @since 3.16.0
    */
    std::optional<TagSupportType> tagSupport;
    /*
    The client support partial workspace symbols. The client will send the
    request `workspaceSymbol/resolve` to the server to resolve additional
    properties.

    @since 3.17.0
    */
    std::optional<ResolveSupportType> resolveSupport;
};

struct CompletionClientCapabilities
{
    struct CompletionItemType
    {
        struct TagSupportType
        {
            // The tags supported by the client.
            std::vector<CompletionItemTag> valueSet;
        };
        struct ResolveSupportType
        {
            // The properties that a client can resolve lazily.
            std::vector<std::string> properties;
        };
        struct InsertTextModeSupportType
        {
            std::vector<InsertTextMode> valueSet;
        };
        /*
        Client supports snippets as insert text.

        A snippet can define tab stops and placeholders with `$1`, `$2`
        and `${3:foo}`. `$0` defines the final tab stop, it defaults to
        the end of the snippet. Placeholders with equal identifiers are linked,
        that is typing in one will update others too.
        */
        std::optional<bool> snippetSupport;
        // Client supports commit characters on a completion item.
        std::optional<bool> commitCharactersSupport;
        /*
        Client supports the following content formats for the documentation
        property. The order describes the preferred format of the client.
        */
        std::optional<std::vector<MarkupKind>> documentationFormat;
        // Client supports the deprecated property on a completion item.
        std::optional<bool> deprecatedSupport;
        // Client supports the preselect property on a completion item.
        std::optional<bool> preselectSupport;
        /*
        Client supports the tag property on a completion item. Clients supporting
        tags have to handle unknown tags gracefully. Clients especially need to
        preserve unknown tags when sending a completion item back to the server in
        a resolve call.

        @since 3.15.0
        */
        std::optional<TagSupportType> tagSupport;
        /*
        Client support insert replace edit to control different behavior if a
        completion item is inserted in the text or should replace text.

        @since 3.16.0
        */
        std::optional<bool> insertReplaceSupport;
        /*
        Indicates which properties a client can resolve lazily on a completion
        item. Before version 3.16.0 only the predefined properties `documentation`
        and `details` could be resolved lazily.

        @since 3.16.0
        */
        std::optional<ResolveSupportType> resolveSupport;
        /*
        The client supports the `insertTextMode` property on
        a completion item to override the whitespace handling mode
        as defined by the client (see `insertTextMode`).

        @since 3.16.0
        */
        std::optional<InsertTextModeSupportType> insertTextModeSupport;
        /*
        The client has support for completion item label
        details (see also `CompletionItemLabelDetails`).

        @since 3.17.0
        */
        std::optional<bool> labelDetailsSupport;
    };
    struct CompletionItemKindType
    {
        /*
        The completion item kind values the client supports. When this
        property exists the client also guarantees that it will
        handle values outside its set gracefully and falls back
        to a default value when unknown.

        If this property is not present the client only supports
        the completion items kinds from `Text` to `Reference` as defined in
        the initial version of the protocol.
        */
        std::optional<std::vector<CompletionItemKind>> valueSet;
    };
    struct CompletionListType
    {
        /*
        The client supports the following itemDefaults on
        a completion list.

        The value lists the supported property names of the
        `CompletionList.itemDefaults` object. If omitted
        no properties are supported.

        @since 3.17.0
        */
        std::optional<std::vector<std::string>> itemDefaults;
    };
    // Whether completion supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    The client supports the following `CompletionItem` specific
    capabilities.
    */
    std::optional<CompletionItemType> completionItem;
    std::optional<CompletionItemKindType> completionItemKind;
    /*
    Defines how the client handles whitespace and indentation
    when accepting a completion item that uses multi line
    text in either `insertText` or `textEdit`.

    @since 3.17.0
    */
    std::optional<InsertTextMode> insertTextMode;
    /*
    The client supports to send additional context information for a
    `textDocument/completion` request.
    */
    std::optional<bool> contextSupport;
    /*
    The client supports the following `CompletionList` specific
    capabilities.

    @since 3.17.0
    */
    std::optional<CompletionListType> completionList;
};

struct TextDocumentSyncClientCapabilities
{
    // Whether text document synchronization supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    // The client supports sending will save notifications.
    std::optional<bool> willSave;
    /*
    The client supports sending a will save request and
    waits for a response providing text edits which will
    be applied to the document before it is saved.
    */
    std::optional<bool> willSaveWaitUntil;
    // The client supports did save notifications.
    std::optional<bool> didSave;
};

struct DiagnosticWorkspaceClientCapabilities
{
    /*
    Whether the client implementation supports a refresh request sent from
    the server to the client.

    Note that this event is global and will force the client to refresh all
    pulled diagnostics currently shown. It should be used with absolute care and
    is useful for situation where a server for example detects a project wide
    change that requires such a calculation.
    */
    std::optional<bool> refreshSupport;
};

struct InlayHintWorkspaceClientCapabilities
{
    /*
    Whether the client implementation supports a refresh request sent from
    the server to the client.

    Note that this event is global and will force the client to refresh all
    inlay hints currently shown. It should be used with absolute care and
    is useful for situation where a server for example detects a project wide
    change that requires such a calculation.
    */
    std::optional<bool> refreshSupport;
};

struct DeleteFileOptions
{
    // Delete the content recursively if a folder is denoted.
    std::optional<bool> recursive;
    // Ignore the operation if the file doesn't exist.
    std::optional<bool> ignoreIfNotExists;
};

struct FileOperationClientCapabilities
{
    // Whether the client supports dynamic registration for file requests/notifications.
    std::optional<bool> dynamicRegistration;
    // The client has support for sending didCreateFiles notifications.
    std::optional<bool> didCreate;
    // The client has support for sending willCreateFiles requests.
    std::optional<bool> willCreate;
    // The client has support for sending didRenameFiles notifications.
    std::optional<bool> didRename;
    // The client has support for sending willRenameFiles requests.
    std::optional<bool> willRename;
    // The client has support for sending didDeleteFiles notifications.
    std::optional<bool> didDelete;
    // The client has support for sending willDeleteFiles requests.
    std::optional<bool> willDelete;
};

struct CodeLensWorkspaceClientCapabilities
{
    /*
    Whether the client implementation supports a refresh request sent from the
    server to the client.

    Note that this event is global and will force the client to refresh all
    code lenses currently shown. It should be used with absolute care and is
    useful for situation where a server for example detect a project wide
    change that requires such a calculation.
    */
    std::optional<bool> refreshSupport;
};

struct SemanticTokensWorkspaceClientCapabilities
{
    /*
    Whether the client implementation supports a refresh request sent from
    the server to the client.

    Note that this event is global and will force the client to refresh all
    semantic tokens currently shown. It should be used with absolute care
    and is useful for situation where a server for example detects a project
    wide change that requires such a calculation.
    */
    std::optional<bool> refreshSupport;
};

struct DocumentLinkClientCapabilities
{
    // Whether document link supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    Whether the client supports the `tooltip` property on `DocumentLink`.

    @since 3.15.0
    */
    std::optional<bool> tooltipSupport;
};

struct DidChangeWatchedFilesClientCapabilities
{
    /*
    Did change watched files notification supports dynamic registration. Please note
    that the current protocol doesn't support static configuration for file changes
    from the server side.
    */
    std::optional<bool> dynamicRegistration;
    /*
    Whether the client has support for {@link  RelativePattern relative pattern}
    or not.

    @since 3.17.0
    */
    std::optional<bool> relativePatternSupport;
};

struct DidChangeConfigurationClientCapabilities
{
    // Did change configuration notification supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct WorkspaceEditClientCapabilities
{
    struct ChangeAnnotationSupportType
    {
        /*
        Whether the client groups edits with equal labels into tree nodes,
        for instance all edits labelled with "Changes in Strings" would
        be a tree node.
        */
        std::optional<bool> groupsOnLabel;
    };
    // The client supports versioned document changes in `WorkspaceEdit`s
    std::optional<bool> documentChanges;
    /*
    The resource operations the client supports. Clients should at least
    support 'create', 'rename' and 'delete' files and folders.

    @since 3.13.0
    */
    std::optional<std::vector<ResourceOperationKind>> resourceOperations;
    /*
    The failure handling strategy of a client if applying the workspace edit
    fails.

    @since 3.13.0
    */
    std::optional<FailureHandlingKind> failureHandling;
    /*
    Whether the client normalizes line endings to the client specific
    setting.
    If set to `true` the client will normalize line ending characters
    in a workspace edit to the client-specified new line
    character.

    @since 3.16.0
    */
    std::optional<bool> normalizesLineEndings;
    /*
    Whether the client in general supports change annotations on text edits,
    create file, rename file and delete file changes.

    @since 3.16.0
    */
    std::optional<ChangeAnnotationSupportType> changeAnnotationSupport;
};

struct ExecutionSummary
{
    /*
    A strict monotonically increasing value
    indicating the execution order of a cell
    inside a notebook.
    */
    unsigned int executionOrder;
    /*
    Whether the execution was successful or
    not if known by the client.
    */
    std::optional<bool> success;
};

struct SemanticTokensLegend
{
    // The token types a server uses.
    std::vector<std::string> tokenTypes;
    // The token modifiers a server uses.
    std::vector<std::string> tokenModifiers;
};

struct SemanticTokensClientCapabilities
{
    struct RequestsType
    {
        struct RangeType
        {
        };
        struct FullType
        {
            /*
            The client will send the `textDocument/semanticTokens/full/delta` request if
            the server provides a corresponding handler.
            */
            std::optional<bool> delta;
        };
        /*
        The client will send the `textDocument/semanticTokens/range` request if
        the server provides a corresponding handler.
        */
        std::optional<std::variant<bool, RangeType>> range;
        /*
        The client will send the `textDocument/semanticTokens/full` request if
        the server provides a corresponding handler.
        */
        std::optional<std::variant<bool, FullType>> full;
    };
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    /*
    Which requests the client supports and might send to the server
    depending on the server's capability. Please note that clients might not
    show semantic tokens or degrade some of the user experience if a range
    or full request is advertised by the client but not provided by the
    server. If for example the client capability `requests.full` and
    `request.range` are both set to true but the server only provides a
    range provider the client might not render a minimap correctly or might
    even decide to not show any semantic tokens at all.
    */
    RequestsType requests;
    // The token types that the client supports.
    std::vector<std::string> tokenTypes;
    // The token modifiers that the client supports.
    std::vector<std::string> tokenModifiers;
    // The token formats the clients supports.
    std::vector<TokenFormat> formats;
    // Whether the client supports tokens that can overlap each other.
    std::optional<bool> overlappingTokenSupport;
    // Whether the client supports tokens that can span multiple lines.
    std::optional<bool> multilineTokenSupport;
    /*
    Whether the client allows the server to actively cancel a
    semantic token request, e.g. supports returning
    LSPErrorCodes.ServerCancelled. If a server does the client
    needs to retrigger the request.

    @since 3.17.0
    */
    std::optional<bool> serverCancelSupport;
    /*
    Whether the client uses semantic tokens to augment existing
    syntax tokens. If set to `true` client side created syntax
    tokens and semantic tokens are both used for colorization. If
    set to `false` the client only uses the returned semantic tokens
    for colorization.

    If the value is `undefined` then the client behavior is not
    specified.

    @since 3.17.0
    */
    std::optional<bool> augmentsSyntaxTokens;
};

struct CallHierarchyClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

struct PublishDiagnosticsClientCapabilities
{
    struct TagSupportType
    {
        // The tags supported by the client.
        std::vector<DiagnosticTag> valueSet;
    };
    // Whether the clients accepts diagnostics with related information.
    std::optional<bool> relatedInformation;
    /*
    Client supports the tag property to provide meta data about a diagnostic.
    Clients supporting tags have to handle unknown tags gracefully.

    @since 3.15.0
    */
    std::optional<TagSupportType> tagSupport;
    /*
    Whether the client interprets the version property of the
    `textDocument/publishDiagnostics` notification's parameter.

    @since 3.15.0
    */
    std::optional<bool> versionSupport;
    /*
    Client supports a codeDescription property

    @since 3.16.0
    */
    std::optional<bool> codeDescriptionSupport;
    /*
    Whether code action supports the `data` property which is
    preserved between a `textDocument/publishDiagnostics` and
    `textDocument/codeAction` request.

    @since 3.16.0
    */
    std::optional<bool> dataSupport;
};

struct NotebookDocumentSyncClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is
    set to `true` the client supports the new
    `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    // The client supports sending execution summary data per cell.
    std::optional<bool> executionSummarySupport;
};

struct FoldingRangeClientCapabilities
{
    struct FoldingRangeKindType
    {
        /*
        The folding range kind values the client supports. When this
        property exists the client also guarantees that it will
        handle values outside its set gracefully and falls back
        to a default value when unknown.
        */
        std::optional<std::vector<FoldingRangeKind>> valueSet;
    };
    struct FoldingRangeType
    {
        /*
        If set, the client signals that it supports setting collapsedText on
        folding ranges to display custom labels instead of the default text.

        @since 3.17.0
        */
        std::optional<bool> collapsedText;
    };
    /*
    Whether implementation supports dynamic registration for folding range
    providers. If this is set to `true` the client supports the new
    `FoldingRangeRegistrationOptions` return value for the corresponding
    server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    /*
    The maximum number of folding ranges that the client prefers to receive
    per document. The value serves as a hint, servers are free to follow the
    limit.
    */
    std::optional<unsigned int> rangeLimit;
    /*
    If set, the client signals that it only supports folding complete lines.
    If set, client will ignore specified `startCharacter` and `endCharacter`
    properties in a FoldingRange.
    */
    std::optional<bool> lineFoldingOnly;
    /*
    Specific options for the folding range kind.

    @since 3.17.0
    */
    std::optional<FoldingRangeKindType> foldingRangeKind;
    /*
    Specific options for the folding range.

    @since 3.17.0
    */
    std::optional<FoldingRangeType> foldingRange;
};

struct RenameClientCapabilities
{
    // Whether rename supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    Client supports testing for validity of rename operations
    before execution.

    @since 3.12.0
    */
    std::optional<bool> prepareSupport;
    /*
    Client supports the default behavior result.

    The value indicates the default behavior used by the
    client.

    @since 3.16.0
    */
    std::optional<PrepareSupportDefaultBehavior> prepareSupportDefaultBehavior;
    /*
    Whether the client honors the change annotations in
    text edits and resource operations returned via the
    rename request's workspace edit by for example presenting
    the workspace edit in the user interface and asking
    for confirmation.

    @since 3.16.0
    */
    std::optional<bool> honorsChangeAnnotations;
};

struct DocumentOnTypeFormattingClientCapabilities
{
    // Whether on type formatting supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct DocumentRangeFormattingClientCapabilities
{
    // Whether range formatting supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct DocumentFormattingClientCapabilities
{
    // Whether formatting supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct DeclarationClientCapabilities
{
    /*
    Whether declaration supports dynamic registration. If this is set to `true`
    the client supports the new `DeclarationRegistrationOptions` return value
    for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    // The client supports additional metadata in the form of declaration links.
    std::optional<bool> linkSupport;
};

struct ExecuteCommandClientCapabilities
{
    // Execute command supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct CodeLensClientCapabilities
{
    // Whether code lens supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct CodeActionClientCapabilities
{
    struct CodeActionLiteralSupportType
    {
        struct CodeActionKindType
        {
            /*
            The code action kind values the client supports. When this
            property exists the client also guarantees that it will
            handle values outside its set gracefully and falls back
            to a default value when unknown.
            */
            std::vector<CodeActionKind> valueSet;
        };
        /*
        The code action kind is support with the following value
        set.
        */
        CodeActionKindType codeActionKind;
    };
    struct ResolveSupportType
    {
        // The properties that a client can resolve lazily.
        std::vector<std::string> properties;
    };
    // Whether code action supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    The client support code action literals of type `CodeAction` as a valid
    response of the `textDocument/codeAction` request. If the property is not
    set the request can only return `Command` literals.

    @since 3.8.0
    */
    std::optional<CodeActionLiteralSupportType> codeActionLiteralSupport;
    /*
    Whether code action supports the `isPreferred` property.

    @since 3.15.0
    */
    std::optional<bool> isPreferredSupport;
    /*
    Whether code action supports the `disabled` property.

    @since 3.16.0
    */
    std::optional<bool> disabledSupport;
    /*
    Whether code action supports the `data` property which is
    preserved between a `textDocument/codeAction` and a
    `codeAction/resolve` request.

    @since 3.16.0
    */
    std::optional<bool> dataSupport;
    /*
    Whether the client supports resolving additional code action
    properties via a separate `codeAction/resolve` request.

    @since 3.16.0
    */
    std::optional<ResolveSupportType> resolveSupport;
    /*
    Whether the client honors the change annotations in
    text edits and resource operations returned via the
    `CodeAction#edit` property by for example presenting
    the workspace edit in the user interface and asking
    for confirmation.

    @since 3.16.0
    */
    std::optional<bool> honorsChangeAnnotations;
};

struct DocumentSymbolClientCapabilities
{
    struct SymbolKindType
    {
        /*
        The symbol kind values the client supports. When this
        property exists the client also guarantees that it will
        handle values outside its set gracefully and falls back
        to a default value when unknown.

        If this property is not present the client only supports
        the symbol kinds from `File` to `Array` as defined in
        the initial version of the protocol.
        */
        std::optional<std::vector<SymbolKind>> valueSet;
    };
    struct TagSupportType
    {
        // The tags supported by the client.
        std::vector<SymbolTag> valueSet;
    };
    // Whether document symbol supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    Specific capabilities for the `SymbolKind` in the
    `textDocument/documentSymbol` request.
    */
    std::optional<SymbolKindType> symbolKind;
    // The client supports hierarchical document symbols.
    std::optional<bool> hierarchicalDocumentSymbolSupport;
    /*
    The client supports tags on `SymbolInformation`. Tags are supported on
    `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
    Clients supporting tags have to handle unknown tags gracefully.

    @since 3.16.0
    */
    std::optional<TagSupportType> tagSupport;
    /*
    The client supports an additional label presented in the UI when
    registering a document symbol provider.

    @since 3.16.0
    */
    std::optional<bool> labelSupport;
};

struct TextDocumentFilter_1
{
    /* A language id, like `typescript`. */
    std::string language;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`. */
    std::optional<std::string> scheme;
    /* A glob pattern, like `*.{ts,js}`. */
    std::optional<std::string> pattern;
};

struct ReferenceClientCapabilities
{
    // Whether references supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct ImplementationClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `ImplementationRegistrationOptions` return value
    for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    /*
    The client supports additional metadata in the form of definition links.

    @since 3.14.0
    */
    std::optional<bool> linkSupport;
};

struct TypeDefinitionClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `TypeDefinitionRegistrationOptions` return value
    for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    /*
    The client supports additional metadata in the form of definition links.

    Since 3.14.0
    */
    std::optional<bool> linkSupport;
};

struct DefinitionClientCapabilities
{
    // Whether definition supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    The client supports additional metadata in the form of definition links.

    @since 3.14.0
    */
    std::optional<bool> linkSupport;
};

struct DocumentColorClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `DocumentColorRegistrationOptions` return value
    for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

struct SignatureHelpClientCapabilities
{
    struct SignatureInformationType
    {
        struct ParameterInformationType
        {
            /*
            The client supports processing label offsets instead of a
            simple label string.

            @since 3.14.0
            */
            std::optional<bool> labelOffsetSupport;
        };
        /*
        Client supports the following content formats for the documentation
        property. The order describes the preferred format of the client.
        */
        std::optional<std::vector<MarkupKind>> documentationFormat;
        // Client capabilities specific to parameter information.
        std::optional<ParameterInformationType> parameterInformation;
        /*
        The client supports the `activeParameter` property on `SignatureInformation`
        literal.

        @since 3.16.0
        */
        std::optional<bool> activeParameterSupport;
    };
    // Whether signature help supports dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    The client supports the following `SignatureInformation`
    specific properties.
    */
    std::optional<SignatureInformationType> signatureInformation;
    /*
    The client supports to send additional context information for a
    `textDocument/signatureHelp` request. A client that opts into
    contextSupport will also support the `retriggerCharacters` on
    `SignatureHelpOptions`.

    @since 3.15.0
    */
    std::optional<bool> contextSupport;
};

struct NotebookDocumentFilter_2
{
    /* The type of the enclosing notebook. */
    std::optional<std::string> notebookType;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`.*/
    std::string scheme;
    /* A glob pattern. */
    std::optional<std::string> pattern;
};

struct NotebookDocumentFilter_1
{
    /* The type of the enclosing notebook. */
    std::string notebookType;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`. */
    std::optional<std::string> scheme;
    /* A glob pattern. */
    std::optional<std::string> pattern;
};

struct TextDocumentFilter_3
{
    /* A language id, like `typescript`. */
    std::optional<std::string> language;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`. */
    std::optional<std::string> scheme;
    /* A glob pattern, like `*.{ts,js}`. */
    std::string pattern;
};

struct TextDocumentFilter_2
{
    /* A language id, like `typescript`. */
    std::optional<std::string> language;
    /* A Uri [scheme](#Uri.scheme), like `file` or `untitled`. */
    std::string scheme;
    /* A glob pattern, like `*.{ts,js}`. */
    std::optional<std::string> pattern;
};

struct DocumentHighlightClientCapabilities
{
    // Whether document highlight supports dynamic registration.
    std::optional<bool> dynamicRegistration;
};

struct MarkedStringFull
{
    std::string language;
    std::string value;
};

struct TextDocumentContentChangeEventFull
{
    // The new text of the whole document.
    std::string text;
};

struct PrepareRenameResult_2
{
    bool defaultBehavior;
};

struct MonikerClientCapabilities
{
    /*
    Whether moniker supports dynamic registration. If this is set to `true`
    the client supports the new `MonikerRegistrationOptions` return value
    for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

struct MarkdownClientCapabilities
{
    // The name of the parser.
    std::string parser;
    // The version of the parser.
    std::optional<std::string> version;
    /*
    A list of HTML tags that the client allows / supports in
    Markdown.

    @since 3.17.0
    */
    std::optional<std::vector<std::string>> allowedTags;
};

struct RegularExpressionsClientCapabilities
{
    // The engine's name.
    std::string engine;
    // The engine's version.
    std::optional<std::string> version;
};

struct ShowDocumentClientCapabilities
{
    /*
    The client has support for the showDocument
    request.
    */
    bool support;
};

struct ShowMessageRequestClientCapabilities
{
    struct MessageActionItemType
    {
        /*
        Whether the client supports additional attributes which
        are preserved and send back to the server in the
        request's response.
        */
        std::optional<bool> additionalPropertiesSupport;
    };
    // Capabilities specific to the `MessageActionItem` type.
    std::optional<MessageActionItemType> messageActionItem;
};

struct SelectionRangeClientCapabilities
{
    /*
    Whether implementation supports dynamic registration for selection range providers. If this is set to `true`
    the client supports the new `SelectionRangeRegistrationOptions` return value for the corresponding server
    capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

struct DiagnosticClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
    // Whether the clients supports related documents for document diagnostic pulls.
    std::optional<bool> relatedDocumentSupport;
};

struct InlayHintClientCapabilities
{
    struct ResolveSupportType
    {
        // The properties that a client can resolve lazily.
        std::vector<std::string> properties;
    };
    // Whether inlay hints support dynamic registration.
    std::optional<bool> dynamicRegistration;
    /*
    Indicates which properties a client can resolve lazily on an inlay
    hint.
    */
    std::optional<ResolveSupportType> resolveSupport;
};

struct InlineValueClientCapabilities
{
    // Whether implementation supports dynamic registration for inline value providers.
    std::optional<bool> dynamicRegistration;
};

struct TypeHierarchyClientCapabilities
{
    /*
    Whether implementation supports dynamic registration. If this is set to `true`
    the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
    return value for the corresponding server capability as well.
    */
    std::optional<bool> dynamicRegistration;
};

/*
MarkedString can be used to render human readable text. It is either a markdown string
or a code-block that provides a language and a code snippet. The language identifier
is semantically equal to the optional language identifier in fenced code blocks in GitHub
issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting

The pair of a language and a value is an equivalent to markdown:
```${language}
${value}
```

Note that markdown strings will be sanitized - that means html will be escaped.
@deprecated use MarkupContent instead.
*/
using MarkedString = std::variant<std::string, MarkedStringFull>;

// A document filter denotes a document by different properties like
// the [language](#TextDocument.languageId), the [scheme](#Uri.scheme) of
// its resource, or a glob-pattern that is applied to the [path](#TextDocument.fileName).

// Glob patterns can have the following syntax:
// - `*` to match one or more characters in a path segment
// - `?` to match on one character in a path segment
// - `**` to match any number of path segments, including none
// - `{}` to group sub patterns into an OR expression. (e.g. `**‚Äã/*.{ts,js}` matches all TypeScript and JavaScript
// files)
// - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`,
// `example.1`, ‚Ä¶)
// - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on
// `example.a`, `example.b`, but not `example.0`)

// @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
// @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`

// @since 3.17.0
using TextDocumentFilter = std::variant<TextDocumentFilter_1, TextDocumentFilter_2, TextDocumentFilter_3>;

struct ConfigurationParams
{
    std::vector<ConfigurationItem> items;
};

struct WorkspaceFolder
{
    // The associated URI for this workspace folder.
    URI uri;
    /*
    The name of the workspace folder. Used to refer to this
    workspace folder in the user interface.
    */
    std::string name;
};

/*
A notebook document filter denotes a notebook document by
different properties. The properties will be match
against the notebook's URI (same as with documents)

@since 3.17.0
*/
using NotebookDocumentFilter =
    std::variant<NotebookDocumentFilter_1, NotebookDocumentFilter_2, NotebookDocumentFilter_3>;

struct SemanticTokensDeltaPartialResult
{
    std::vector<SemanticTokensEdit> edits;
};

struct SemanticTokensDelta
{
    std::optional<std::string> resultId;
    // The semantic token edits to transform a previous result into a new result.
    std::vector<SemanticTokensEdit> edits;
};

struct CreateFilesParams
{
    // An array of all files/folders created in this operation.
    std::vector<FileCreate> files;
};

struct WorkDoneProgressCancelParams
{
    // The token to be used to report progress.
    ProgressToken token;
};

struct WorkDoneProgressCreateParams
{
    // The token to be used to report progress.
    ProgressToken token;
};

struct PartialResultParams
{
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DeleteFilesParams
{
    // An array of all files/folders deleted in this operation.
    std::vector<FileDelete> files;
};

struct RenameFilesParams
{
    /*
    An array of all files/folders renamed in this operation. When a folder is renamed, only
    the folder will be included, and not its children.
    */
    std::vector<FileRename> files;
};

struct ShowMessageRequestParams
{
    // The message type. See {@link MessageType}
    MessageType type;
    // The actual message.
    std::string message;
    // The message action items to present.
    std::optional<std::vector<MessageActionItem>> actions;
};

struct RegistrationParams
{
    std::vector<Registration> registrations;
};

struct DidOpenTextDocumentParams
{
    // The document that was opened.
    TextDocumentItem textDocument;
};

struct DidChangeWatchedFilesParams
{
    // The actual file events.
    std::vector<FileEvent> changes;
};

struct WillSaveTextDocumentParams
{
    // The document that will be saved.
    TextDocumentIdentifier textDocument;
    // The 'TextDocumentSaveReason'.
    TextDocumentSaveReason reason;
};

struct DidSaveTextDocumentParams
{
    // The document that was saved.
    TextDocumentIdentifier textDocument;
    /*
    Optional the content when saved. Depends on the includeText value
    when the save notification was requested.
    */
    std::optional<std::string> text;
};

struct DidCloseTextDocumentParams
{
    // The document that was closed.
    TextDocumentIdentifier textDocument;
};

struct UnregistrationParams
{
    std::vector<Unregistration> unregisterations;
};

struct DocumentOnTypeFormattingParams
{
    // The document to format.
    TextDocumentIdentifier textDocument;
    /*
    The position around which the on type formatting should happen.
    This is not necessarily the exact position where the character denoted
    by the property `ch` got typed.
    */
    Position position;
    /*
    The character that has been typed that triggered the formatting
    on type request. That is not necessarily the last character that
    got inserted into the document since the client could auto insert
    characters as well (e.g. like automatic brace completion).
    */
    std::string ch;
    // The formatting options.
    FormattingOptions options;
};

struct ProgressParams
{
    // The progress token provided by the client or server.
    ProgressToken token;
    // The progress data.
    nlohmann::json value;
};

struct LinkedEditingRangeOptions
{
    std::optional<bool> workDoneProgress;
};

struct SemanticTokensOptions
{
    struct RangeType
    {
    };
    struct FullType
    {
        // The server supports deltas for full documents.
        std::optional<bool> delta;
    };
    // The legend used by the server
    SemanticTokensLegend legend;
    /*
    Server supports providing semantic tokens for a specific range
    of a document.
    */
    std::optional<std::variant<bool, RangeType>> range;
    // Server supports providing semantic tokens for a full document.
    std::optional<std::variant<bool, FullType>> full;
    std::optional<bool> workDoneProgress;
};

struct SelectionRangeOptions
{
    std::optional<bool> workDoneProgress;
};

struct DeclarationOptions
{
    std::optional<bool> workDoneProgress;
};

struct FoldingRangeOptions
{
    std::optional<bool> workDoneProgress;
};

struct DocumentColorOptions
{
    std::optional<bool> workDoneProgress;
};

struct TypeDefinitionOptions
{
    std::optional<bool> workDoneProgress;
};

struct ImplementationOptions
{
    std::optional<bool> workDoneProgress;
};

struct Range
{
    // The range's start position.
    Position start;
    // The range's end position.
    Position end;
};

struct WorkDoneProgressParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct InlayHintOptions
{
    /*
    The server provides support to resolve additional
    information for an inlay hint item.
    */
    std::optional<bool> resolveProvider;
    std::optional<bool> workDoneProgress;
};

struct InlineValueOptions
{
    std::optional<bool> workDoneProgress;
};

struct TypeHierarchyOptions
{
    std::optional<bool> workDoneProgress;
};

struct MonikerOptions
{
    std::optional<bool> workDoneProgress;
};

struct CallHierarchyOptions
{
    std::optional<bool> workDoneProgress;
};

struct VersionedTextDocumentIdentifier : public TextDocumentIdentifier
{
    // The version number of this document.
    int version;
};

struct CompletionOptions
{
    struct CompletionItemType
    {
        /*
        The server has support for completion item label
        details (see also `CompletionItemLabelDetails`) when
        receiving a completion item in a resolve call.

        @since 3.17.0
        */
        std::optional<bool> labelDetailsSupport;
    };
    /*
    Most tools trigger completion request automatically without explicitly requesting
    it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user
    starts to type an identifier. For example if the user types `c` in a JavaScript file
    code complete will automatically pop up present `console` besides others as a
    completion item. Characters that make up identifiers don't need to be listed here.

    If code complete should automatically be trigger on characters not being valid inside
    an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.
    */
    std::optional<std::vector<std::string>> triggerCharacters;
    /*
    The list of all possible characters that commit a completion. This field can be used
    if clients don't support individual commit characters per completion item. See
    `ClientCapabilities.textDocument.completion.completionItem.commitCharactersSupport`

    If a server provides both `allCommitCharacters` and commit characters on an individual
    completion item the ones on the completion item win.

    @since 3.2.0
    */
    std::optional<std::vector<std::string>> allCommitCharacters;
    /*
    The server provides support to resolve additional
    information for a completion item.
    */
    std::optional<bool> resolveProvider;
    /*
    The server supports the following `CompletionItem` specific
    capabilities.

    @since 3.17.0
    */
    std::optional<CompletionItemType> completionItem;
    std::optional<bool> workDoneProgress;
};

struct DiagnosticOptions
{
    /*
    An optional identifier under which the diagnostics are
    managed by the client.
    */
    std::optional<std::string> identifier;
    /*
    Whether the language has inter file dependencies meaning that
    editing code in one file can result in a different diagnostic
    set in another file. Inter file dependencies are common for
    most programming languages and typically uncommon for linters.
    */
    bool interFileDependencies;
    // The server provides support for workspace diagnostics as well.
    bool workspaceDiagnostics;
    std::optional<bool> workDoneProgress;
};

struct NotebookDocumentIdentifier
{
    // The notebook document's uri.
    URI uri;
};

struct VersionedNotebookDocumentIdentifier
{
    // The version number of this notebook document.
    int version;
    // The notebook document's uri.
    URI uri;
};

struct ExecuteCommandOptions
{
    // The commands to be executed on the server
    std::vector<std::string> commands;
    std::optional<bool> workDoneProgress;
};

struct RenameOptions
{
    /*
    Renames should be checked and tested before being executed.

    @since version 3.12.0
    */
    std::optional<bool> prepareProvider;
    std::optional<bool> workDoneProgress;
};

struct DocumentRangeFormattingOptions
{
    std::optional<bool> workDoneProgress;
};

struct DocumentFormattingOptions
{
    std::optional<bool> workDoneProgress;
};

struct DocumentLinkOptions
{
    // Document links have a resolve provider as well.
    std::optional<bool> resolveProvider;
    std::optional<bool> workDoneProgress;
};

struct CodeLensOptions
{
    // Code lens has a resolve provider as well.
    std::optional<bool> resolveProvider;
    std::optional<bool> workDoneProgress;
};

struct WorkspaceSymbolOptions
{
    /*
    The server provides support to resolve additional
    information for a workspace symbol.

    @since 3.17.0
    */
    std::optional<bool> resolveProvider;
    std::optional<bool> workDoneProgress;
};

struct CodeActionOptions
{
    /*
    CodeActionKinds that this server may return.

    The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
    may list out every specific kind they provide.
    */
    std::optional<std::vector<CodeActionKind>> codeActionKinds;
    /*
    The server provides support to resolve additional
    information for a code action.

    @since 3.16.0
    */
    std::optional<bool> resolveProvider;
    std::optional<bool> workDoneProgress;
};

struct HoverOptions
{
    std::optional<bool> workDoneProgress;
};

struct DocumentSymbolOptions
{
    /*
    A human-readable string that is shown when multiple outlines trees
    are shown for the same document.

    @since 3.16.0
    */
    std::optional<std::string> label;
    std::optional<bool> workDoneProgress;
};

struct DocumentHighlightOptions
{
    std::optional<bool> workDoneProgress;
};

struct ReferenceOptions
{
    std::optional<bool> workDoneProgress;
};

struct DefinitionOptions
{
    std::optional<bool> workDoneProgress;
};

struct SignatureHelpOptions
{
    // List of characters that trigger signature help automatically.
    std::optional<std::vector<std::string>> triggerCharacters;
    /*
    List of characters that re-trigger signature help.

    These trigger characters are only active when signature help is already showing. All trigger characters
    are also counted as re-trigger characters.

    @since 3.15.0
    */
    std::optional<std::vector<std::string>> retriggerCharacters;
    std::optional<bool> workDoneProgress;
};

struct OptionalVersionedTextDocumentIdentifier : public TextDocumentIdentifier
{
    /*
    The version number of this document. If a versioned text document identifier
    is sent from the server to the client and the file is not open in the editor
    (the server has not received an open notification before) the server can send
    `null` to indicate that the version is unknown and the content on disk is the
    truth (as specified with document content ownership).
    */
    std::variant<int, std::nullptr_t> version;
};

struct ParameterInformation
{
    /*
    The label of this parameter information.

    Either a string or an inclusive start and exclusive end offsets within its containing
    signature label. (see SignatureInformation.label). The offsets are based on a UTF-16
    string representation as `Position` and `Range` does.

    *Note*: a label of type string should be a substring of its containing signature label.
    Its intended use case is to highlight the parameter label part in the `SignatureInformation.label`.
    */
    std::variant<std::string, std::tuple<unsigned int, unsigned int>> label;
    /*
    The human-readable doc-comment of this parameter. Will be shown
    in the UI but can be omitted.
    */
    std::optional<std::variant<std::string, MarkupContent>> documentation;
};

struct CodeDescription
{
    // An URI to open with more information about the diagnostic error.
    URI href;
};

struct WindowClientCapabilities
{
    /*
    It indicates whether the client supports server initiated
    progress using the `window/workDoneProgress/create` request.

    The capability also controls Whether client supports handling
    of progress notifications. If set servers are allowed to report a
    `workDoneProgress` property in the request specific server
    capabilities.

    @since 3.15.0
    */
    std::optional<bool> workDoneProgress;
    /*
    Capabilities specific to the showMessage request.

    @since 3.16.0
    */
    std::optional<ShowMessageRequestClientCapabilities> showMessage;
    /*
    Capabilities specific to the showDocument request.

    @since 3.16.0
    */
    std::optional<ShowDocumentClientCapabilities> showDocument;
};

struct TextDocumentSyncOptions
{
    /*
    Open and close notifications are sent to the server. If omitted open close notifications should not
    be sent.
    */
    std::optional<bool> openClose;
    /*
    Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
    and TextDocumentSyncKind.Incremental. If omitted it defaults to TextDocumentSyncKind.None.
    */
    std::optional<TextDocumentSyncKind> change;
    /*
    If present will save notifications are sent to the server. If omitted the notification should not be
    sent.
    */
    std::optional<bool> willSave;
    /*
    If present will save wait until requests are sent to the server. If omitted the request should not be
    sent.
    */
    std::optional<bool> willSaveWaitUntil;
    /*
    If present save notifications are sent to the server. If omitted the notification should not be
    sent.
    */
    std::optional<std::variant<bool, SaveOptions>> save;
};

struct NotebookCell
{
    // The cell's kind
    NotebookCellKind kind;
    /*
    The URI of the cell's text document
    content.
    */
    DocumentUri document;
    /*
    Additional metadata stored with the cell.

    Note: should always be an object literal (e.g. LSPObject)
    */
    std::optional<nlohmann::json> metadata;
    /*
    Additional execution summary information
    if supported by the client.
    */
    std::optional<ExecutionSummary> executionSummary;
};

struct WorkspaceUnchangedDocumentDiagnosticReport : public UnchangedDocumentDiagnosticReport
{
    // The URI for which diagnostic information is reported.
    DocumentUri uri;
    /*
    The version number for which the diagnostics are reported.
    If the document is not marked as open `null` can be provided.
    */
    std::variant<int, std::nullptr_t> version;
};

struct FileOperationPattern
{

    // The glob pattern to match. Glob patterns can have the following syntax:
    // - `*` to match one or more characters in a path segment
    // - `?` to match on one character in a path segment
    // - `**` to match any number of path segments, including none
    // - `{}` to group sub patterns into an OR expression. (e.g. `**‚Äã/*.{ts,js}` matches all TypeScript and JavaScript
    // files)
    // - `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on
    // `example.0`, `example.1`, ‚Ä¶)
    // - `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on
    // `example.a`, `example.b`, but not `example.0`)

    std::string glob;
    /*
    Whether to match files or folders with this pattern.

    Matches both if undefined.
    */
    std::optional<FileOperationPatternKind> matches;
    // Additional options used during matching.
    std::optional<FileOperationPatternOptions> options;
};

struct ResourceOperation
{
    // The resource operation kind.
    std::string kind;
    /*
    An optional annotation identifier describing the operation.

    @since 3.16.0
    */
    std::optional<ChangeAnnotationIdentifier> annotationId;
};

struct GeneralClientCapabilities
{
    struct StaleRequestSupportType
    {
        // The client will actively cancel the request.
        bool cancel;
        /*
        The list of requests for which the client
        will retry the request if it receives a
        response with error code `ContentModified`
        */
        std::vector<std::string> retryOnContentModified;
    };
    /*
    Client capability that signals how the client
    handles stale requests (e.g. a request
    for which the client will not process the response
    anymore since the information is outdated).

    @since 3.17.0
    */
    std::optional<StaleRequestSupportType> staleRequestSupport;
    /*
    Client capabilities specific to regular expressions.

    @since 3.16.0
    */
    std::optional<RegularExpressionsClientCapabilities> regularExpressions;
    /*
    Client capabilities specific to the client's markdown parser.

    @since 3.16.0
    */
    std::optional<MarkdownClientCapabilities> markdown;
    /*
    The position encodings supported by the client. Client and server
    have to agree on the same position encoding to ensure that offsets
    (e.g. character position in a line) are interpreted the same on both
    sides.

    To keep the protocol backwards compatible the following applies: if
    the value 'utf-16' is missing from the array of position encodings
    servers can assume that the client supports UTF-16. UTF-16 is
    therefore a mandatory encoding.

    If omitted it defaults to ['utf-16'].

    Implementation considerations: since the conversion from one encoding
    into another requires the content of the file / line the conversion
    is best done where the file is read which is usually on the server
    side.

    @since 3.17.0
    */
    std::optional<std::vector<PositionEncodingKind>> positionEncodings;
};

struct NotebookDocumentClientCapabilities
{
    /*
    Capabilities specific to notebook document synchronization

    @since 3.17.0
    */
    NotebookDocumentSyncClientCapabilities synchronization;
};

struct TextDocumentClientCapabilities
{
    // Defines which synchronization capabilities the client supports.
    std::optional<TextDocumentSyncClientCapabilities> synchronization;
    // Capabilities specific to the `textDocument/completion` request.
    std::optional<CompletionClientCapabilities> completion;
    // Capabilities specific to the `textDocument/hover` request.
    std::optional<HoverClientCapabilities> hover;
    // Capabilities specific to the `textDocument/signatureHelp` request.
    std::optional<SignatureHelpClientCapabilities> signatureHelp;
    /*
    Capabilities specific to the `textDocument/declaration` request.

    @since 3.14.0
    */
    std::optional<DeclarationClientCapabilities> declaration;
    // Capabilities specific to the `textDocument/definition` request.
    std::optional<DefinitionClientCapabilities> definition;
    /*
    Capabilities specific to the `textDocument/typeDefinition` request.

    @since 3.6.0
    */
    std::optional<TypeDefinitionClientCapabilities> typeDefinition;
    /*
    Capabilities specific to the `textDocument/implementation` request.

    @since 3.6.0
    */
    std::optional<ImplementationClientCapabilities> implementation;
    // Capabilities specific to the `textDocument/references` request.
    std::optional<ReferenceClientCapabilities> references;
    // Capabilities specific to the `textDocument/documentHighlight` request.
    std::optional<DocumentHighlightClientCapabilities> documentHighlight;
    // Capabilities specific to the `textDocument/documentSymbol` request.
    std::optional<DocumentSymbolClientCapabilities> documentSymbol;
    // Capabilities specific to the `textDocument/codeAction` request.
    std::optional<CodeActionClientCapabilities> codeAction;
    // Capabilities specific to the `textDocument/codeLens` request.
    std::optional<CodeLensClientCapabilities> codeLens;
    // Capabilities specific to the `textDocument/documentLink` request.
    std::optional<DocumentLinkClientCapabilities> documentLink;
    /*
    Capabilities specific to the `textDocument/documentColor` and the
    `textDocument/colorPresentation` request.

    @since 3.6.0
    */
    std::optional<DocumentColorClientCapabilities> colorProvider;
    // Capabilities specific to the `textDocument/formatting` request.
    std::optional<DocumentFormattingClientCapabilities> formatting;
    // Capabilities specific to the `textDocument/rangeFormatting` request.
    std::optional<DocumentRangeFormattingClientCapabilities> rangeFormatting;
    // Capabilities specific to the `textDocument/onTypeFormatting` request.
    std::optional<DocumentOnTypeFormattingClientCapabilities> onTypeFormatting;
    // Capabilities specific to the `textDocument/rename` request.
    std::optional<RenameClientCapabilities> rename;
    /*
    Capabilities specific to the `textDocument/foldingRange` request.

    @since 3.10.0
    */
    std::optional<FoldingRangeClientCapabilities> foldingRange;
    /*
    Capabilities specific to the `textDocument/selectionRange` request.

    @since 3.15.0
    */
    std::optional<SelectionRangeClientCapabilities> selectionRange;
    // Capabilities specific to the `textDocument/publishDiagnostics` notification.
    std::optional<PublishDiagnosticsClientCapabilities> publishDiagnostics;
    /*
    Capabilities specific to the various call hierarchy requests.

    @since 3.16.0
    */
    std::optional<CallHierarchyClientCapabilities> callHierarchy;
    /*
    Capabilities specific to the various semantic token request.

    @since 3.16.0
    */
    std::optional<SemanticTokensClientCapabilities> semanticTokens;
    /*
    Capabilities specific to the `textDocument/linkedEditingRange` request.

    @since 3.16.0
    */
    std::optional<LinkedEditingRangeClientCapabilities> linkedEditingRange;
    /*
    Client capabilities specific to the `textDocument/moniker` request.

    @since 3.16.0
    */
    std::optional<MonikerClientCapabilities> moniker;
    /*
    Capabilities specific to the various type hierarchy requests.

    @since 3.17.0
    */
    std::optional<TypeHierarchyClientCapabilities> typeHierarchy;
    /*
    Capabilities specific to the `textDocument/inlineValue` request.

    @since 3.17.0
    */
    std::optional<InlineValueClientCapabilities> inlineValue;
    /*
    Capabilities specific to the `textDocument/inlayHint` request.

    @since 3.17.0
    */
    std::optional<InlayHintClientCapabilities> inlayHint;
    /*
    Capabilities specific to the diagnostic pull model.

    @since 3.17.0
    */
    std::optional<DiagnosticClientCapabilities> diagnostic;
};

struct WorkspaceClientCapabilities
{
    /*
    The client supports applying batch edits
    to the workspace by supporting the request
    'workspace/applyEdit'
    */
    std::optional<bool> applyEdit;
    // Capabilities specific to `WorkspaceEdit`s.
    std::optional<WorkspaceEditClientCapabilities> workspaceEdit;
    // Capabilities specific to the `workspace/didChangeConfiguration` notification.
    std::optional<DidChangeConfigurationClientCapabilities> didChangeConfiguration;
    // Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
    std::optional<DidChangeWatchedFilesClientCapabilities> didChangeWatchedFiles;
    // Capabilities specific to the `workspace/symbol` request.
    std::optional<WorkspaceSymbolClientCapabilities> symbol;
    // Capabilities specific to the `workspace/executeCommand` request.
    std::optional<ExecuteCommandClientCapabilities> executeCommand;
    /*
    The client has support for workspace folders.

    @since 3.6.0
    */
    std::optional<bool> workspaceFolders;
    /*
    The client supports `workspace/configuration` requests.

    @since 3.6.0
    */
    std::optional<bool> configuration;
    /*
    Capabilities specific to the semantic token requests scoped to the
    workspace.

    @since 3.16.0.
    */
    std::optional<SemanticTokensWorkspaceClientCapabilities> semanticTokens;
    /*
    Capabilities specific to the code lens requests scoped to the
    workspace.

    @since 3.16.0.
    */
    std::optional<CodeLensWorkspaceClientCapabilities> codeLens;
    /*
    The client has support for file notifications/requests for user operations on files.

    Since 3.16.0
    */
    std::optional<FileOperationClientCapabilities> fileOperations;
    /*
    Capabilities specific to the inline values requests scoped to the
    workspace.

    @since 3.17.0.
    */
    std::optional<InlineValueWorkspaceClientCapabilities> inlineValue;
    /*
    Capabilities specific to the inlay hint requests scoped to the
    workspace.

    @since 3.17.0.
    */
    std::optional<InlayHintWorkspaceClientCapabilities> inlayHint;
    /*
    Capabilities specific to the diagnostic requests scoped to the
    workspace.

    @since 3.17.0.
    */
    std::optional<DiagnosticWorkspaceClientCapabilities> diagnostics;
};

struct TextDocumentPositionParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The position inside the text document.
    Position position;
};

struct ColorInformation
{
    // The range in the document where this color appears.
    Range range;
    // The actual color value for this color range.
    Color color;
};

struct Location
{
    DocumentUri uri;
    Range range;
};

struct CallHierarchyItem
{
    // The name of this item.
    std::string name;
    // The kind of this item.
    SymbolKind kind;
    // Tags for this item.
    std::optional<std::vector<SymbolTag>> tags;
    // More detail for this item, e.g. the signature of a function.
    std::optional<std::string> detail;
    // The resource identifier of this item.
    DocumentUri uri;
    // The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and
    // code.
    Range range;
    /*
    The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
    Must be contained by the [`range`](#CallHierarchyItem.range).
    */
    Range selectionRange;
    /*
    A data entry field that is preserved between a call hierarchy prepare and
    incoming calls or outgoing calls requests.
    */
    std::optional<nlohmann::json> data;
};

struct CallHierarchyPrepareParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct SemanticTokensDeltaParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    /*
    The result id of a previous response. The result Id can either point to a full response
    or a delta response depending on what was received last.
    */
    std::string previousResultId;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct SemanticTokensParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct ColorPresentationParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The color to request presentations for.
    Color color;
    // The range where the color would be inserted. Serves as a context.
    Range range;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct SelectionRangeParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The positions inside the text document.
    std::vector<Position> positions;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct FoldingRangeParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentColorParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct TypeDefinitionParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentLinkParams
{
    // The document to provide document links for.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct SemanticTokensRangeParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The range the semantic tokens are requested for.
    Range range;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct InlayHintParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The document range for which inlay hints should be computed.
    Range range;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct DeclarationParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct TypeHierarchyItem
{
    // The name of this item.
    std::string name;
    // The kind of this item.
    SymbolKind kind;
    // Tags for this item.
    std::optional<std::vector<SymbolTag>> tags;
    // More detail for this item, e.g. the signature of a function.
    std::optional<std::string> detail;
    // The resource identifier of this item.
    DocumentUri uri;
    /*
    The range enclosing this symbol not including leading/trailing whitespace
    but everything else, e.g. comments and code.
    */
    Range range;
    /*
    The range that should be selected and revealed when this symbol is being
    picked, e.g. the name of a function. Must be contained by the
    [`range`](#TypeHierarchyItem.range).
    */
    Range selectionRange;
    /*
    A data entry field that is preserved between a type hierarchy prepare and
    supertypes or subtypes requests. It could also be used to identify the
    type hierarchy in the server, helping improve the performance on
    resolving supertypes and subtypes.
    */
    std::optional<nlohmann::json> data;
};

struct TypeHierarchyPrepareParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct MonikerParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentDiagnosticParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The additional identifier  provided during registration.
    std::optional<std::string> identifier;
    // The result id of a previous response if provided.
    std::optional<std::string> previousResultId;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct LinkedEditingRangeParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct ShowDocumentParams
{
    // The document uri to show.
    URI uri;
    /*
    Indicates to show the resource in an external program.
    To show for example `https://code.visualstudio.com/`
    in the default WEB browser set `external` to `true`.
    */
    std::optional<bool> external;
    /*
    An optional property to indicate whether the editor
    showing the document should take focus or not.
    Clients might ignore this property if an external
    program is started.
    */
    std::optional<bool> takeFocus;
    /*
    An optional selection range if the document is a text
    document. Clients might ignore the property if an
    external program is started or the file is not a text
    file.
    */
    std::optional<Range> selection;
};

struct LinkedEditingRanges
{
    /*
    A list of ranges that can be edited together. The ranges must have
    identical length and contain identical text content. The ranges cannot overlap.
    */
    std::vector<Range> ranges;
    /*
    An optional word pattern (regular expression) that describes valid contents for
    the given ranges. If no pattern is provided, the client configuration's word
    pattern will be used.
    */
    std::optional<std::string> wordPattern;
};

struct DidCloseNotebookDocumentParams
{
    // The notebook document that got closed.
    NotebookDocumentIdentifier notebookDocument;
    /*
    The text documents that represent the content
    of a notebook cell that got closed.
    */
    std::vector<TextDocumentIdentifier> cellTextDocuments;
};

struct DidSaveNotebookDocumentParams
{
    // The notebook document that got saved.
    NotebookDocumentIdentifier notebookDocument;
};

struct HoverParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct WorkspaceDiagnosticParams
{
    // The additional identifier provided during registration.
    std::optional<std::string> identifier;
    /*
    The currently known diagnostic reports with their
    previous result ids.
    */
    std::vector<PreviousResultId> previousResultIds;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct PrepareRenameParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct Hover
{
    // The hover's content
    std::variant<MarkedString, MarkupContent, std::vector<MarkedString>> contents;
    /*
    An optional range inside the text document that is used to
    visualize the hover, e.g. by changing the background color.
    */
    std::optional<Range> range;
};

struct TextEdit
{
    /*
    The range of the text document to be manipulated. To insert
    text into a document create a range where start === end.
    */
    Range range;
    /*
    The string to be inserted. For delete operations use an
    empty string.
    */
    std::string newText;
};

struct ImplementationParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct CodeLensParams
{
    // The document to request code lens for.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct WorkspaceSymbolParams
{
    /*
    A query string to filter symbols by. Clients may send an empty
    string here to request all symbols.
    */
    std::string query;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct CodeLens
{
    // The range in which this code lens is valid. Should only span a single line.
    Range range;
    // The command this code lens represents.
    std::optional<Command> command;
    /*
    A data entry field that is preserved on a code lens item between
    a [CodeLensRequest](#CodeLensRequest) and a [CodeLensResolveRequest]
    (#CodeLensResolveRequest)
    */
    std::optional<nlohmann::json> data;
};

struct CompletionParams : public TextDocumentPositionParams
{
    /*
    The completion context. This is only available it the client specifies
    to send this using the client capability `textDocument.completion.contextSupport === true`
    */
    std::optional<CompletionContext> context;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentSymbol
{
    /*
    The name of this symbol. Will be displayed in the user interface and therefore must not be
    an empty string or a string only consisting of white spaces.
    */
    std::string name;
    // More detail for this symbol, e.g the signature of a function.
    std::optional<std::string> detail;
    // The kind of this symbol.
    SymbolKind kind;
    /*
    Tags for this document symbol.

    @since 3.16.0
    */
    std::optional<std::vector<SymbolTag>> tags;
    /*
    Indicates if this symbol is deprecated.

    @deprecated Use tags instead
    */
    std::optional<bool> deprecated;
    /*
    The range enclosing this symbol not including leading/trailing whitespace but everything else
    like comments. This information is typically used to determine if the clients cursor is
    inside the symbol to reveal in the symbol in the UI.
    */
    Range range;
    /*
    The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
    Must be contained by the `range`.
    */
    Range selectionRange;
    // Children of this symbol, e.g. properties of a class.
    std::optional<std::vector<DocumentSymbol>> children;
};

struct DocumentSymbolParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentHighlight
{
    // The range this highlight applies to.
    Range range;
    // The highlight kind, default is [text](#DocumentHighlightKind.Text).
    std::optional<DocumentHighlightKind> kind;
};

struct DocumentHighlightParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct ReferenceParams : public TextDocumentPositionParams
{
    ReferenceContext context;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct ExecuteCommandRegistrationOptions : public ExecuteCommandOptions
{
};

struct ExecuteCommandParams
{
    // The identifier of the actual command handler.
    std::string command;
    // Arguments that the command should be invoked with.
    std::optional<std::vector<nlohmann::json>> arguments;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct DocumentLink
{
    // The range this link applies to.
    Range range;
    // The uri this link points to. If missing a resolve request is sent later.
    std::optional<std::string> target;
    /*
    The tooltip text when you hover over this link.

    If a tooltip is provided, is will be displayed in a string that includes instructions on how to
    trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
    user settings, and localization.

    @since 3.15.0
    */
    std::optional<std::string> tooltip;
    /*
    A data entry field that is preserved on a document link between a
    DocumentLinkRequest and a DocumentLinkResolveRequest.
    */
    std::optional<nlohmann::json> data;
};

struct RenameParams
{
    // The document to rename.
    TextDocumentIdentifier textDocument;
    // The position at which this request was sent.
    Position position;
    /*
    The new name of the symbol. If the given name is not valid the
    request must return a [ResponseError](#ResponseError) with an
    appropriate message set.
    */
    std::string newName;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct WorkspaceSymbolRegistrationOptions : public WorkspaceSymbolOptions
{
};

struct DocumentRangeFormattingParams
{
    // The document to format.
    TextDocumentIdentifier textDocument;
    // The range to format
    Range range;
    // The format options
    FormattingOptions options;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct DocumentFormattingParams
{
    // The document to format.
    TextDocumentIdentifier textDocument;
    // The format options.
    FormattingOptions options;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct FileOperationFilter
{
    // A Uri scheme like `file` or `untitled`.
    std::optional<std::string> scheme;
    // The actual file operation pattern.
    FileOperationPattern pattern;
};

struct WorkspaceFoldersChangeEvent
{
    // The array of added workspace folders
    std::vector<WorkspaceFolder> added;
    // The array of the removed workspace folders
    std::vector<WorkspaceFolder> removed;
};

struct LocationLink
{
    /*
    Span of the origin of this link.

    Used as the underlined span for mouse interaction. Defaults to the word range at
    the definition position.
    */
    std::optional<Range> originSelectionRange;
    // The target resource identifier of this link.
    DocumentUri targetUri;
    /*
    The full target range of this link. If the target for example is a symbol then target range is the
    range enclosing this symbol not including leading/trailing whitespace but everything else
    like comments. This information is typically used to highlight the range in the editor.
    */
    Range targetRange;
    /*
    The range that should be selected and revealed when this link is being followed, e.g the name of a function.
    Must be contained by the `targetRange`. See also `DocumentSymbol#range`
    */
    Range targetSelectionRange;
};

struct InlineValueContext
{
    // The stack frame (as a DAP Id) where the execution has stopped.
    int frameId;
    /*
    The document range where execution has stopped.
    Typically the end position of the range denotes the line where the inline values are shown.
    */
    Range stoppedLocation;
};

struct InlineValueEvaluatableExpression
{
    /*
    The document range for which the inline value applies.
    The range is used to extract the evaluatable expression from the underlying document.
    */
    Range range;
    // If specified the expression overrides the extracted expression.
    std::optional<std::string> expression;
};

struct InlineValueVariableLookup
{
    /*
    The document range for which the inline value applies.
    The range is used to extract the variable name from the underlying document.
    */
    Range range;
    // If specified the name of the variable to look up.
    std::optional<std::string> variableName;
    // How to perform the lookup.
    bool caseSensitiveLookup;
};

struct DeleteFile : public ResourceOperation
{
    // A delete
    static inline const std::string kind = "delete";
    // The file to delete.
    DocumentUri uri;
    // Delete options.
    std::optional<DeleteFileOptions> options;
};

struct RenameFile : public ResourceOperation
{
    // A rename
    static inline const std::string kind = "rename";
    // The old (existing) location.
    DocumentUri oldUri;
    // The new location.
    DocumentUri newUri;
    // Rename options.
    std::optional<RenameFileOptions> options;
};

struct CreateFile : public ResourceOperation
{
    // A create
    static inline const std::string kind = "create";
    // The resource to create.
    DocumentUri uri;
    // Additional options
    std::optional<CreateFileOptions> options;
};

struct DefinitionParams : public TextDocumentPositionParams
{
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct InsertReplaceEdit
{
    // The string to be inserted.
    std::string newText;
    // The range if the insert is requested
    Range insert;
    // The range if the replace is requested.
    Range replace;
};

struct InlineValueText
{
    // The document range for which the inline value applies.
    Range range;
    // The text of the inline value.
    std::string text;
};

struct NotebookDocument
{
    // The notebook document's uri.
    URI uri;
    // The type of the notebook.
    std::string notebookType;
    /*
    The version number of this document (it will increase after each
    change, including undo/redo).
    */
    int version;
    /*
    Additional metadata stored with the notebook
    document.

    Note: should always be an object literal (e.g. LSPObject)
    */
    std::optional<nlohmann::json> metadata;
    // The cells of a notebook.
    std::vector<NotebookCell> cells;
};

struct WorkspaceFoldersInitializeParams
{
    /*
    The workspace folders configured in the client when the server starts.

    This property is only available if the client supports workspace folders.
    It can be `null` if the client supports workspace folders but none are
    configured.

    @since 3.6.0
    */
    std::optional<std::variant<std::vector<WorkspaceFolder>, std::nullptr_t>> workspaceFolders;
};

struct SignatureInformation
{
    /*
    The label of this signature. Will be shown in
    the UI.
    */
    std::string label;
    /*
    The human-readable doc-comment of this signature. Will be shown
    in the UI but can be omitted.
    */
    std::optional<std::variant<std::string, MarkupContent>> documentation;
    // The parameters of this signature.
    std::optional<std::vector<ParameterInformation>> parameters;
    /*
    The index of the active parameter.

    If provided, this is used in place of `SignatureHelp.activeParameter`.

    @since 3.16.0
    */
    std::optional<unsigned int> activeParameter;
};

struct NotebookDocumentSyncOptions
{
    struct NotebookSelectorType
    {
        struct CellsType
        {
            std::string language;
        };
        /*
        The notebook to be synced If a string
        value is provided it matches against the
        notebook type. '*' matches every notebook.
        */
        std::optional<std::variant<std::string, NotebookDocumentFilter>> notebook;
        // The cells of the matching notebook to be synced.
        std::optional<std::vector<CellsType>> cells;
    };
    // The notebooks to be synced
    std::vector<NotebookSelectorType> notebookSelector;
    /*
    Whether save notification should be forwarded to
    the server. Will only be honored if mode === `notebook`.
    */
    std::optional<bool> save;
};

struct ClientCapabilities
{
    // Workspace specific client capabilities.
    std::optional<WorkspaceClientCapabilities> workspace;
    // Text document specific client capabilities.
    std::optional<TextDocumentClientCapabilities> textDocument;
    /*
    Capabilities specific to the notebook document support.

    @since 3.17.0
    */
    std::optional<NotebookDocumentClientCapabilities> notebookDocument;
    // Window specific client capabilities.
    std::optional<WindowClientCapabilities> window;
    /*
    General client capabilities.

    @since 3.16.0
    */
    std::optional<GeneralClientCapabilities> general;
    // Experimental client capabilities.
    std::optional<nlohmann::json> experimental;
};

struct NotebookCellTextDocumentFilter
{
    /*
    A filter that matches against the notebook
    containing the notebook cell. If a string
    value is provided it matches against the
    notebook type. '*' matches every notebook.
    */
    std::variant<std::string, NotebookDocumentFilter> notebook;
    /*
    A language id like `python`.

    Will be matched against the language id of the
    notebook cell document. '*' matches every language.
    */
    std::optional<std::string> language;
};

struct PrepareRenameResult_1
{
    Range range;
    std::string placeholder;
};

struct SelectionRange
{
    // The [range](#Range) of this selection range.
    Range range;
    // The parent selection range containing this range. Therefore `parent.range` must contain `this.range`.
    std::unique_ptr<SelectionRange> parent;
};

struct RelativePattern
{
    /*
    A workspace folder or a base URI to which this pattern will be matched
    against relatively.
    */
    std::variant<WorkspaceFolder, URI> baseUri;
    // The actual glob pattern;
    Pattern pattern;
};

struct NotebookCellArrayChange
{
    // The start oftest of the cell that changed.
    unsigned int start;
    // The deleted cells
    unsigned int deleteCount;
    // The new cells, if any
    std::optional<std::vector<NotebookCell>> cells;
};

struct TextDocumentContentChangeEventPartial
{
    // The range of the document that changed.
    Range range;
    /*
    The optional length of the range that got replaced.

    @deprecated use range instead.
    */
    std::optional<unsigned int> rangeLength;
    // The new text for the provided range.
    std::string text;
};

/*
The glob pattern. Either a string pattern or a relative pattern.

@since 3.17.0
*/
using GlobPattern = std::variant<Pattern, RelativePattern>;

/*
An event describing a change to a text document. If only a text is provided
it is considered to be the full content of the document.
*/
using TextDocumentContentChangeEvent =
    std::variant<TextDocumentContentChangeEventPartial, TextDocumentContentChangeEventFull>;

using PrepareRenameResult = std::variant<Range, PrepareRenameResult_1, PrepareRenameResult_2>;

/*
Inline value information can be provided by different means:
- directly as a text value (class InlineValueText).
- as a name to use for a variable lookup (class InlineValueVariableLookup)
- as an evaluatable expression (class InlineValueEvaluatableExpression)
The InlineValue types combines all inline value types into one type.

@since 3.17.0
*/
using InlineValue = std::variant<InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression>;

/*
Information about where a symbol is declared.

Provides additional metadata over normal [location](#Location) declarations, including the range of
the declaring symbol.

Servers should prefer returning `DeclarationLink` over `Declaration` if supported
by the client.
*/
using DeclarationLink = LocationLink;

// The declaration of a symbol representation as one or many [locations](#Location).
using Declaration = std::variant<Location, std::vector<Location>>;

/*
Information about where a symbol is defined.

Provides additional metadata over normal [location](#Location) definitions, including the range of
the defining symbol
*/
using DefinitionLink = LocationLink;

/*
The definition of a symbol represented as one or many [locations](#Location).
For most programming languages there is only one location at which a symbol is
defined.

Servers should prefer returning `DefinitionLink` over `Definition` if supported
by the client.
*/
using Definition = std::variant<Location, std::vector<Location>>;

struct ColorPresentation
{
    /*
    The label of this color presentation. It will be shown on the color
    picker header. By default this is also the text that is inserted when selecting
    this color presentation.
    */
    std::string label;
    /*
    An [edit](#TextEdit) which is applied to a document when selecting
    this presentation for the color.  When `falsy` the [label](#ColorPresentation.label)
    is used.
    */
    std::optional<TextEdit> textEdit;
    /*
    An optional array of additional [text edits](#TextEdit) that are applied when
    selecting this color presentation. Edits must not overlap with the main [edit](#ColorPresentation.textEdit) nor with
    themselves.
    */
    std::optional<std::vector<TextEdit>> additionalTextEdits;
};

struct CallHierarchyOutgoingCall
{
    // The item that is called.
    CallHierarchyItem to;
    /*
    The range at which this item is called. This is the range relative to the caller, e.g the item
    passed to [`provideCallHierarchyOutgoingCalls`](#CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls)
    and not [`this.to`](#CallHierarchyOutgoingCall.to).
    */
    std::vector<Range> fromRanges;
};

struct DidChangeWorkspaceFoldersParams
{
    // The actual workspace folder change event.
    WorkspaceFoldersChangeEvent event;
};

/*
A document filter describes a top level text document or
a notebook cell document.

@since 3.17.0 - proposed support for NotebookCellTextDocumentFilter.
*/
using DocumentFilter = std::variant<TextDocumentFilter, NotebookCellTextDocumentFilter>;

struct CallHierarchyIncomingCall
{
    // The item that makes the call.
    CallHierarchyItem from;
    /*
    The ranges at which the calls appear. This is relative to the caller
    denoted by [`this.from`](#CallHierarchyIncomingCall.from).
    */
    std::vector<Range> fromRanges;
};

struct CallHierarchyOutgoingCallsParams
{
    CallHierarchyItem item;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct CallHierarchyIncomingCallsParams
{
    CallHierarchyItem item;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct TypeHierarchySubtypesParams
{
    TypeHierarchyItem item;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct InlineValueParams
{
    // The text document.
    TextDocumentIdentifier textDocument;
    // The document range for which inline values should be computed.
    Range range;
    /*
    Additional information about the context in which inline values were
    requested.
    */
    InlineValueContext context;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct TypeHierarchySupertypesParams
{
    TypeHierarchyItem item;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct FileOperationRegistrationOptions
{
    // The actual filters.
    std::vector<FileOperationFilter> filters;
};

struct SignatureHelp
{
    // One or more signatures.
    std::vector<SignatureInformation> signatures;
    /*
    The active signature. If omitted or the value lies outside the
    range of `signatures` the value defaults to zero or is ignored if
    the `SignatureHelp` has no signatures.

    Whenever possible implementers should make an active decision about
    the active signature and shouldn't rely on a default value.

    In future version of the protocol this property might become
    mandatory to better express this.
    */
    std::optional<unsigned int> activeSignature;
    /*
    The active parameter of the active signature. If omitted or the value
    lies outside the range of `signatures[activeSignature].parameters`
    defaults to 0 if the active signature has parameters. If
    the active signature has no parameters it is ignored.
    In future version of the protocol this property might become
    mandatory to better express the active parameter if the
    active signature does have any.
    */
    std::optional<unsigned int> activeParameter;
};

struct DidOpenNotebookDocumentParams
{
    // The notebook document that got opened.
    NotebookDocument notebookDocument;
    /*
    The text documents that represent the content
    of a notebook cell.
    */
    std::vector<TextDocumentItem> cellTextDocuments;
};

struct CompletionItem
{
    /*
    The label of this completion item.

    The label property is also by default the text that
    is inserted when selecting this completion.

    If label details are provided the label itself should
    be an unqualified name of the completion item.
    */
    std::string label;
    /*
    Additional details for the label

    @since 3.17.0
    */
    std::optional<CompletionItemLabelDetails> labelDetails;
    /*
    The kind of this completion item. Based of the kind
    an icon is chosen by the editor.
    */
    std::optional<CompletionItemKind> kind;
    /*
    Tags for this completion item.

    @since 3.15.0
    */
    std::optional<std::vector<CompletionItemTag>> tags;
    /*
    A human-readable string with additional information
    about this item, like type or symbol information.
    */
    std::optional<std::string> detail;
    // A human-readable string that represents a doc-comment.
    std::optional<std::variant<std::string, MarkupContent>> documentation;
    /*
    Indicates if this item is deprecated.
    @deprecated Use `tags` instead.
    */
    std::optional<bool> deprecated;
    /*
    Select this item when showing.

    *Note* that only one completion item can be selected and that the
    tool / client decides which item that is. The rule is that the *first*
    item of those that match best is selected.
    */
    std::optional<bool> preselect;
    /*
    A string that should be used when comparing this item
    with other items. When `falsy` the [label](#CompletionItem.label)
    is used.
    */
    std::optional<std::string> sortText;
    /*
    A string that should be used when filtering a set of
    completion items. When `falsy` the [label](#CompletionItem.label)
    is used.
    */
    std::optional<std::string> filterText;
    /*
    A string that should be inserted into a document when selecting
    this completion. When `falsy` the [label](#CompletionItem.label)
    is used.

    The `insertText` is subject to interpretation by the client side.
    Some tools might not take the string literally. For example
    VS Code when code complete is requested in this example
    `con<cursor position>` and a completion item with an `insertText` of
    `console` is provided it will only insert `sole`. Therefore it is
    recommended to use `textEdit` instead since it avoids additional client
    side interpretation.
    */
    std::optional<std::string> insertText;
    /*
    The format of the insert text. The format applies to both the
    `insertText` property and the `newText` property of a provided
    `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.

    Please note that the insertTextFormat doesn't apply to
    `additionalTextEdits`.
    */
    std::optional<InsertTextFormat> insertTextFormat;
    /*
    How whitespace and indentation is handled during completion
    item insertion. If not provided the clients default value depends on
    the `textDocument.completion.insertTextMode` client capability.

    @since 3.16.0
    */
    std::optional<InsertTextMode> insertTextMode;
    /*
    An [edit](#TextEdit) which is applied to a document when selecting
    this completion. When an edit is provided the value of
    [insertText](#CompletionItem.insertText) is ignored.

    Most editors support two different operations when accepting a completion
    item. One is to insert a completion text and the other is to replace an
    existing text with a completion text. Since this can usually not be
    predetermined by a server it can report both ranges. Clients need to
    signal support for `InsertReplaceEdits` via the
    `textDocument.completion.insertReplaceSupport` client capability
    property.

    *Note 1:* The text edit's range as well as both ranges from an insert
    replace edit must be a [single line] and they must contain the position
    at which completion has been requested.
    *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range
    must be a prefix of the edit's replace range, that means it must be
    contained and starting at the same position.

    @since 3.16.0 additional type `InsertReplaceEdit`
    */
    std::optional<std::variant<TextEdit, InsertReplaceEdit>> textEdit;
    /*
    The edit text used if the completion item is part of a CompletionList and
    CompletionList defines an item default for the text edit range.

    Clients will only honor this property if they opt into completion list
    item defaults using the capability `completionList.itemDefaults`.

    If not provided and a list's default range is provided the label
    property is used as a text.

    @since 3.17.0
    */
    std::optional<std::string> textEditText;
    /*
    An optional array of additional [text edits](#TextEdit) that are applied when
    selecting this completion. Edits must not overlap (including the same insert position)
    with the main [edit](#CompletionItem.textEdit) nor with themselves.

    Additional text edits should be used to change text unrelated to the current cursor position
    (for example adding an import statement at the top of the file if the completion item will
    insert an unqualified type).
    */
    std::optional<std::vector<TextEdit>> additionalTextEdits;
    /*
    An optional set of characters that when pressed while this completion is active will accept it first and
    then type that character. *Note* that all commit characters should have `length=1` and that superfluous
    characters will be ignored.
    */
    std::optional<std::vector<std::string>> commitCharacters;
    /*
    An optional [command](#Command) that is executed *after* inserting this completion. *Note* that
    additional modifications to the current document should be described with the
    [additionalTextEdits](#CompletionItem.additionalTextEdits)-property.
    */
    std::optional<Command> command;
    /*
    A data entry field that is preserved on a completion item between a
    [CompletionRequest](#CompletionRequest) and a [CompletionResolveRequest](#CompletionResolveRequest).
    */
    std::optional<nlohmann::json> data;
};

struct WorkspaceSymbol : public BaseSymbolInformation
{
    struct LocationType
    {
        DocumentUri uri;
    };
    /*
    The location of the symbol. Whether a server is allowed to
    return a location without a range depends on the client
    capability `workspace.symbol.resolveSupport`.

    See SymbolInformation#location for more details.
    */
    std::variant<Location, LocationType> location;
    /*
    A data entry field that is preserved on a workspace symbol between a
    workspace symbol request and a workspace symbol resolve request.
    */
    std::optional<nlohmann::json> data;
};

struct SymbolInformation : public BaseSymbolInformation
{
    /*
    Indicates if this symbol is deprecated.

    @deprecated Use tags instead
    */
    std::optional<bool> deprecated;
    /*
    The location of this symbol. The location's range is used by a tool
    to reveal the location in the editor. If the symbol is selected in the
    tool the range's start information is used to position the cursor. So
    the range usually spans more than the actual symbol's name and does
    normally include things like visibility modifiers.

    The range doesn't have to denote a node range in the sense of an abstract
    syntax tree. It can therefore not be used to re-construct a hierarchy of
    the symbols.
    */
    Location location;
};

struct InlayHintLabelPart
{
    // The value of this label part.
    std::string value;
    /*
    The tooltip text when you hover over this label part. Depending on
    the client capability `inlayHint.resolveSupport` clients might resolve
    this property late using the resolve request.
    */
    std::optional<std::variant<std::string, MarkupContent>> tooltip;
    /*
    An optional source code location that represents this
    label part.

    The editor will use this location for the hover and for code navigation
    features: This part will become a clickable link that resolves to the
    definition of the symbol at the given location (not necessarily the
    location itself), it shows the hover that shows at the given location,
    and it shows a context menu with further code navigation commands.

    Depending on the client capability `inlayHint.resolveSupport` clients
    might resolve this property late using the resolve request.
    */
    std::optional<Location> location;
    /*
    An optional command for this label part.

    Depending on the client capability `inlayHint.resolveSupport` clients
    might resolve this property late using the resolve request.
    */
    std::optional<Command> command;
};

struct _InitializeParams
{
    struct ClientInfoType
    {
        // The name of the client as defined by the client.
        std::string name;
        // The client's version as defined by the client.
        std::optional<std::string> version;
    };
    /*
    The process Id of the parent process that started
    the server.

    Is `null` if the process has not been started by another process.
    If the parent process is not alive then the server should exit.
    */
    std::variant<int, std::nullptr_t> processId;
    /*
    Information about the client

    @since 3.15.0
    */
    std::optional<ClientInfoType> clientInfo;
    /*
    The locale the client is currently showing the user interface
    in. This must not necessarily be the locale of the operating
    system.

    Uses IETF language tags as the value's syntax
    (See https://en.wikipedia.org/wiki/IETF_language_tag)

    @since 3.16.0
    */
    std::optional<std::string> locale;
    /*
    The rootPath of the workspace. Is null
    if no folder is open.

    @deprecated in favour of rootUri.
    */
    std::optional<std::variant<std::string, std::nullptr_t>> rootPath;
    /*
    The rootUri of the workspace. Is null if no
    folder is open. If both `rootPath` and `rootUri` are set
    `rootUri` wins.

    @deprecated in favour of workspaceFolders.
    */
    std::variant<DocumentUri, std::nullptr_t> rootUri;
    // The capabilities provided by the client (editor or tool)
    ClientCapabilities capabilities;
    // User provided initialization options.
    std::optional<nlohmann::json> initializationOptions;
    // The initial trace setting. If omitted trace is disabled ('off').
    static inline const std::string trace_off = "off";
    static inline const std::string trace_messages = "messages";
    static inline const std::string trace_compact = "compact";
    static inline const std::string trace_verbose = "verbose";
    std::optional<std::string> trace;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct DiagnosticRelatedInformation
{
    // The location of this related diagnostic information.
    Location location;
    // The message of this related diagnostic information.
    std::string message;
};

struct NotebookDocumentSyncRegistrationOptions : public NotebookDocumentSyncOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct AnnotatedTextEdit : public TextEdit
{
    // The actual identifier of the change annotation
    ChangeAnnotationIdentifier annotationId;
};

/*
A document selector is the combination of one or many document filters.

@sample `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**‚àïtsconfig.json' }]`;

The use of a string as a document filter is deprecated @since 3.16.0.
*/
using DocumentSelector = std::vector<std::variant<std::string, DocumentFilter>>;

struct InlayHint
{
    // The position of this hint.
    Position position;
    /*
    The label of this hint. A human readable string or an array of
    InlayHintLabelPart label parts.

    *Note* that neither the string nor the label part can be empty.
    */
    std::variant<std::string, std::vector<InlayHintLabelPart>> label;
    /*
    The kind of this hint. Can be omitted in which case the client
    should fall back to a reasonable default.
    */
    std::optional<InlayHintKind> kind;
    /*
    Optional text edits that are performed when accepting this inlay hint.

    *Note* that edits are expected to change the document so that the inlay
    hint (or its nearest variant) is now part of the document and the inlay
    hint itself is now obsolete.
    */
    std::optional<std::vector<TextEdit>> textEdits;
    // The tooltip text when you hover over this item.
    std::optional<std::variant<std::string, MarkupContent>> tooltip;
    /*
    Render padding before the hint.

    Note: Padding should use the editor's background color, not the
    background color of the hint itself. That means padding can be used
    to visually align/separate an inlay hint.
    */
    std::optional<bool> paddingLeft;
    /*
    Render padding after the hint.

    Note: Padding should use the editor's background color, not the
    background color of the hint itself. That means padding can be used
    to visually align/separate an inlay hint.
    */
    std::optional<bool> paddingRight;
    /*
    A data entry field that is preserved on an inlay hint between
    a `textDocument/inlayHint` and a `inlayHint/resolve` request.
    */
    std::optional<nlohmann::json> data;
};

struct InitializeParams : public _InitializeParams, public WorkspaceFoldersInitializeParams
{
};

struct CompletionList
{
    struct ItemDefaultsType
    {
        struct EditRangeType
        {
            Range insert;
            Range replace;
        };
        /*
        A default commit character set.

        @since 3.17.0
        */
        std::optional<std::vector<std::string>> commitCharacters;
        /*
        A default edit range.

        @since 3.17.0
        */
        std::optional<std::variant<Range, EditRangeType>> editRange;
        /*
        A default insert text format.

        @since 3.17.0
        */
        std::optional<InsertTextFormat> insertTextFormat;
        /*
        A default insert text mode.

        @since 3.17.0
        */
        std::optional<InsertTextMode> insertTextMode;
        /*
        A default data value.

        @since 3.17.0
        */
        std::optional<nlohmann::json> data;
    };
    /*
    This list it not complete. Further typing results in recomputing this list.

    Recomputed lists have all their items replaced (not appended) in the
    incomplete completion sessions.
    */
    bool isIncomplete;
    /*
    In many cases the items of an actual completion result share the same
    value for properties like `commitCharacters` or the range of a text
    edit. A completion list can therefore define item defaults which will
    be used if a completion item itself doesn't specify the value.

    If a completion list specifies a default value and a completion item
    also specifies a corresponding value the one from the item is used.

    Servers are only allowed to return default values if the client
    signals support for this via the `completionList.itemDefaults`
    capability.

    @since 3.17.0
    */
    std::optional<ItemDefaultsType> itemDefaults;
    // The completion items.
    std::vector<CompletionItem> items;
};

struct DidChangeTextDocumentParams
{
    /*
    The document that did change. The version number points
    to the version after all provided content changes have
    been applied.
    */
    VersionedTextDocumentIdentifier textDocument;
    /*
    The actual content changes. The content changes describe single state changes
    to the document. So if there are two content changes c1 (at array index 0) and
    c2 (at array index 1) for a document in state S then c1 moves the document from
    S to S' and c2 from S' to S''. So c1 is computed on the state S and c2 is computed
    on the state S'.

    To mirror the content of a document using change events use the following approach:
    - start with the same initial content
    - apply the 'textDocument/didChange' notifications in the order you receive them.
    - apply the `TextDocumentContentChangeEvent`s in a single notification in the order
      you receive them.
    */
    std::vector<TextDocumentContentChangeEvent> contentChanges;
};

struct FileSystemWatcher
{
    /*
    The glob pattern to watch. See {@link GlobPattern glob pattern} for more detail.

    @since 3.17.0 support for relative patterns.
    */
    GlobPattern globPattern;
    /*
    The kind of events of interest. If omitted it defaults
    to WatchKind.Create | WatchKind.Change | WatchKind.Delete
    which is 7.
    */
    std::optional<WatchKind> kind;
};

struct NotebookDocumentChangeEvent
{
    struct CellsType
    {
        struct StructureType
        {
            // The change to the cell array.
            NotebookCellArrayChange array;
            // Additional opened cell text documents.
            std::optional<std::vector<TextDocumentItem>> didOpen;
            // Additional closed cell text documents.
            std::optional<std::vector<TextDocumentIdentifier>> didClose;
        };
        struct TextContentType
        {
            VersionedTextDocumentIdentifier document;
            std::vector<TextDocumentContentChangeEvent> changes;
        };
        /*
        Changes to the cell structure to add or
        remove cells.
        */
        std::optional<StructureType> structure;
        /*
        Changes to notebook cells properties like its
        kind, execution summary or metadata.
        */
        std::optional<std::vector<NotebookCell>> data;
        // Changes to the text content of notebook cells.
        std::optional<std::vector<TextContentType>> textContent;
    };
    /*
    The changed meta data if any.

    Note: should always be an object literal (e.g. LSPObject)
    */
    std::optional<nlohmann::json> metadata;
    // Changes to cells
    std::optional<CellsType> cells;
};

struct Diagnostic
{
    // The range at which the message applies
    Range range;
    /*
    The diagnostic's severity. Can be omitted. If omitted it is up to the
    client to interpret diagnostics as error, warning, info or hint.
    */
    std::optional<DiagnosticSeverity> severity;
    // The diagnostic's code, which usually appear in the user interface.
    std::optional<std::variant<int, std::string>> code;
    /*
    An optional property to describe the error code.
    Requires the code field (above) to be present/not null.

    @since 3.16.0
    */
    std::optional<CodeDescription> codeDescription;
    /*
    A human-readable string describing the source of this
    diagnostic, e.g. 'typescript' or 'super lint'. It usually
    appears in the user interface.
    */
    std::optional<std::string> source;
    // The diagnostic's message. It usually appears in the user interface
    std::string message;
    /*
    Additional metadata about the diagnostic.

    @since 3.15.0
    */
    std::optional<std::vector<DiagnosticTag>> tags;
    /*
    An array of related diagnostic information, e.g. when symbol-names within
    a scope collide all definitions can be marked via this property.
    */
    std::optional<std::vector<DiagnosticRelatedInformation>> relatedInformation;
    /*
    A data entry field that is preserved between a `textDocument/publishDiagnostics`
    notification and `textDocument/codeAction` request.

    @since 3.16.0
    */
    std::optional<nlohmann::json> data;
};

struct TextDocumentEdit
{
    // The text document to change.
    OptionalVersionedTextDocumentIdentifier textDocument;
    /*
    The edits to be applied.

    @since 3.16.0 - support for AnnotatedTextEdit. This is guarded using a
    client capability.
    */
    std::vector<std::variant<TextEdit, AnnotatedTextEdit>> edits;
};

struct SignatureHelpContext
{
    // Action that caused signature help to be triggered.
    SignatureHelpTriggerKind triggerKind;
    /*
    Character that caused signature help to be triggered.

    This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
    */
    std::optional<std::string> triggerCharacter;
    /*
    `true` if signature help was already showing when it was triggered.

    Retriggers occurs when the signature help is already active and can be caused by actions such as
    typing a trigger character, a cursor move, or document content changes.
    */
    bool isRetrigger;
    /*
    The currently active `SignatureHelp`.

    The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
    the user navigating through available signatures.
    */
    std::optional<SignatureHelp> activeSignatureHelp;
};

struct FileOperationOptions
{
    // The server is interested in receiving didCreateFiles notifications.
    std::optional<FileOperationRegistrationOptions> didCreate;
    // The server is interested in receiving willCreateFiles requests.
    std::optional<FileOperationRegistrationOptions> willCreate;
    // The server is interested in receiving didRenameFiles notifications.
    std::optional<FileOperationRegistrationOptions> didRename;
    // The server is interested in receiving willRenameFiles requests.
    std::optional<FileOperationRegistrationOptions> willRename;
    // The server is interested in receiving didDeleteFiles file notifications.
    std::optional<FileOperationRegistrationOptions> didDelete;
    // The server is interested in receiving willDeleteFiles file requests.
    std::optional<FileOperationRegistrationOptions> willDelete;
};

struct TextDocumentRegistrationOptions
{
    /*
    A document selector to identify the scope of the registration. If set to null
    the document selector provided on the client side will be used.
    */
    std::variant<DocumentSelector, std::nullptr_t> documentSelector;
};

struct WorkspaceEdit
{
    struct ChangesType
    {
        std::map<DocumentUri, std::vector<TextEdit>> propertyMap;
    };
    struct ChangeAnnotationsType
    {
        std::map<ChangeAnnotationIdentifier, ChangeAnnotation> propertyMap;
    };
    // Holds changes to existing resources.
    std::optional<ChangesType> changes;
    /*
    Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
    are either an array of `TextDocumentEdit`s to express changes to n different text documents
    where each text document edit addresses a specific version of a text document. Or it can contain
    above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.

    Whether a client supports versioned document edits is expressed via
    `workspace.workspaceEdit.documentChanges` client capability.

    If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
    only plain `TextEdit`s using the `changes` property are supported.
    */
    std::optional<std::vector<std::variant<TextDocumentEdit, CreateFile, RenameFile, DeleteFile>>> documentChanges;
    /*
    A map of change annotations that can be referenced in `AnnotatedTextEdit`s or create, rename and
    delete file / folder operations.

    Whether clients honor this property depends on the client capability `workspace.changeAnnotationSupport`.

    @since 3.16.0
    */
    std::optional<ChangeAnnotationsType> changeAnnotations;
};

struct DidChangeNotebookDocumentParams
{
    /*
    The notebook document that did change. The version number points
    to the version after all provided changes have been applied. If
    only the text document content of a cell changes the notebook version
    doesn't necessarily have to change.
    */
    VersionedNotebookDocumentIdentifier notebookDocument;
    /*
    The actual changes to the notebook document.

    The changes describe single state changes to the notebook document.
    So if there are two changes c1 (at array index 0) and c2 (at array
    index 1) for a notebook in state S then c1 moves the notebook from
    S to S' and c2 from S' to S''. So c1 is computed on the state S and
    c2 is computed on the state S'.

    To mirror the content of a notebook using change events use the following approach:
    - start with the same initial content
    - apply the 'notebookDocument/didChange' notifications in the order you receive them.
    - apply the `NotebookChangeEvent`s in a single notification in the order
      you receive them.
    */
    NotebookDocumentChangeEvent change;
};

struct PublishDiagnosticsParams
{
    // The URI for which diagnostic information is reported.
    DocumentUri uri;
    /*
    Optional the version number of the document the diagnostics are published for.

    @since 3.15.0
    */
    std::optional<int> version;
    // An array of diagnostic information items.
    std::vector<Diagnostic> diagnostics;
};

struct SignatureHelpParams : public TextDocumentPositionParams
{
    /*
    The signature help context. This is only available if the client specifies
    to send this using the client capability `textDocument.signatureHelp.contextSupport === true`

    @since 3.15.0
    */
    std::optional<SignatureHelpContext> context;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
};

struct DidChangeWatchedFilesRegistrationOptions
{
    // The watchers to register.
    std::vector<FileSystemWatcher> watchers;
};

struct CodeActionContext
{
    /*
    An array of diagnostics known on the client side overlapping the range provided to the
    `textDocument/codeAction` request. They are provided so that the server knows which
    errors are currently presented to the user for the given range. There is no guarantee
    that these accurately reflect the error state of the resource. The primary parameter
    to compute code actions is the provided range.
    */
    std::vector<Diagnostic> diagnostics;
    /*
    Requested kind of actions to return.

    Actions not of this kind are filtered out by the client before being shown. So servers
    can omit computing them.
    */
    std::optional<std::vector<CodeActionKind>> only;
    /*
    The reason why code actions were requested.

    @since 3.17.0
    */
    std::optional<CodeActionTriggerKind> triggerKind;
};

struct FullDocumentDiagnosticReport
{
    // A full document diagnostic report.
    static inline const std::string kind = "full";
    /*
    An optional result id. If provided it will
    be sent on the next diagnostic request for the
    same document.
    */
    std::optional<std::string> resultId;
    // The actual items.
    std::vector<Diagnostic> items;
};

struct DocumentDiagnosticReportPartialResult
{
    std::map<DocumentUri, std::variant<FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport>>
        relatedDocuments;
};

struct DocumentColorRegistrationOptions : public TextDocumentRegistrationOptions, public DocumentColorOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct FoldingRangeRegistrationOptions : public TextDocumentRegistrationOptions, public FoldingRangeOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct TypeDefinitionRegistrationOptions : public TextDocumentRegistrationOptions, public TypeDefinitionOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct ImplementationRegistrationOptions : public TextDocumentRegistrationOptions, public ImplementationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct DeclarationRegistrationOptions : public DeclarationOptions, public TextDocumentRegistrationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct SemanticTokensRegistrationOptions : public TextDocumentRegistrationOptions, public SemanticTokensOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct SelectionRangeRegistrationOptions : public SelectionRangeOptions, public TextDocumentRegistrationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct CallHierarchyRegistrationOptions : public TextDocumentRegistrationOptions, public CallHierarchyOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct InlayHintRegistrationOptions : public InlayHintOptions, public TextDocumentRegistrationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct InlineValueRegistrationOptions : public InlineValueOptions, public TextDocumentRegistrationOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct TypeHierarchyRegistrationOptions : public TextDocumentRegistrationOptions, public TypeHierarchyOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct MonikerRegistrationOptions : public TextDocumentRegistrationOptions, public MonikerOptions
{
};

struct LinkedEditingRangeRegistrationOptions : public TextDocumentRegistrationOptions, public LinkedEditingRangeOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct TextDocumentSaveRegistrationOptions : public TextDocumentRegistrationOptions, public SaveOptions
{
};

struct DiagnosticRegistrationOptions : public TextDocumentRegistrationOptions, public DiagnosticOptions
{
    /*
    The id used to register the request. The id can be used to deregister
    the request again. See also Registration#id.
    */
    std::optional<std::string> id;
};

struct HoverRegistrationOptions : public TextDocumentRegistrationOptions, public HoverOptions
{
};

struct CompletionRegistrationOptions : public TextDocumentRegistrationOptions, public CompletionOptions
{
};

struct DocumentSymbolRegistrationOptions : public TextDocumentRegistrationOptions, public DocumentSymbolOptions
{
};

struct SignatureHelpRegistrationOptions : public TextDocumentRegistrationOptions, public SignatureHelpOptions
{
};

struct TextDocumentChangeRegistrationOptions : public TextDocumentRegistrationOptions
{
    // How documents are synced to the server.
    TextDocumentSyncKind syncKind;
};

struct CodeLensRegistrationOptions : public TextDocumentRegistrationOptions, public CodeLensOptions
{
};

struct DocumentRangeFormattingRegistrationOptions : public TextDocumentRegistrationOptions,
                                                    public DocumentRangeFormattingOptions
{
};

struct CodeActionRegistrationOptions : public TextDocumentRegistrationOptions, public CodeActionOptions
{
};

struct CodeAction
{
    struct DisabledType
    {
        /*
        Human readable description of why the code action is currently disabled.

        This is displayed in the code actions UI.
        */
        std::string reason;
    };
    // A short, human-readable, title for this code action.
    std::string title;
    /*
    The kind of the code action.

    Used to filter code actions.
    */
    std::optional<CodeActionKind> kind;
    // The diagnostics that this code action resolves.
    std::optional<std::vector<Diagnostic>> diagnostics;
    /*
    Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
    by keybindings.

    A quick fix should be marked preferred if it properly addresses the underlying error.
    A refactoring should be marked preferred if it is the most reasonable choice of actions to take.

    @since 3.15.0
    */
    std::optional<bool> isPreferred;
    /*
    Marks that the code action cannot currently be applied.

    Clients should follow the following guidelines regarding disabled code actions:

      - Disabled code actions are not shown in automatic
    [lightbulbs](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) code action menus.

      - Disabled actions are shown as faded out in the code action menu when the user requests a more specific type
        of code action, such as refactorings.

      - If the user has a
    [keybinding](https://code.visualstudio.com/docs/editor/refactoring#_keybindings-for-code-actions) that auto applies
    a code action and only disabled code actions are returned, the client should show the user an error message with
    `reason` in the editor.

    @since 3.16.0
    */
    std::optional<DisabledType> disabled;
    // The workspace edit this code action performs.
    std::optional<WorkspaceEdit> edit;
    /*
    A command this code action executes. If a code action
    provides an edit and a command, first the edit is
    executed and then the command.
    */
    std::optional<Command> command;
    /*
    A data entry field that is preserved on a code action between
    a `textDocument/codeAction` and a `codeAction/resolve` request.

    @since 3.16.0
    */
    std::optional<nlohmann::json> data;
};

struct DefinitionRegistrationOptions : public TextDocumentRegistrationOptions, public DefinitionOptions
{
};

struct ReferenceRegistrationOptions : public TextDocumentRegistrationOptions, public ReferenceOptions
{
};

struct CodeActionParams
{
    // The document in which the command was invoked.
    TextDocumentIdentifier textDocument;
    // The range for which the command was invoked.
    Range range;
    // Context carrying additional information.
    CodeActionContext context;
    // An optional token that a server can use to report work done progress.
    std::optional<ProgressToken> workDoneToken;
    /*
    An optional token that a server can use to report partial results (e.g. streaming) to
    the client.
    */
    std::optional<ProgressToken> partialResultToken;
};

struct DocumentHighlightRegistrationOptions : public TextDocumentRegistrationOptions, public DocumentHighlightOptions
{
};

struct ApplyWorkspaceEditParams
{
    /*
    An optional label of the workspace edit. This label is
    presented in the user interface for example on an undo
    stack to undo the workspace edit.
    */
    std::optional<std::string> label;
    // The edits to apply.
    WorkspaceEdit edit;
};

struct RenameRegistrationOptions : public TextDocumentRegistrationOptions, public RenameOptions
{
};

struct DocumentOnTypeFormattingRegistrationOptions : public TextDocumentRegistrationOptions,
                                                     public DocumentOnTypeFormattingOptions
{
};

struct DocumentFormattingRegistrationOptions : public TextDocumentRegistrationOptions, public DocumentFormattingOptions
{
};

struct DocumentLinkRegistrationOptions : public TextDocumentRegistrationOptions, public DocumentLinkOptions
{
};

struct RelatedUnchangedDocumentDiagnosticReport : public UnchangedDocumentDiagnosticReport
{
    /*
    Diagnostics of related documents. This information is useful
    in programming languages where code in a file A can generate
    diagnostics in a file B which A depends on. An example of
    such a language is C/C++ where marco definitions in a file
    a.cpp and result in errors in a header file b.hpp.

    @since 3.17.0
    */
    std::optional<std::map<DocumentUri, std::variant<FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport>>>
        relatedDocuments;
};

struct RelatedFullDocumentDiagnosticReport : public FullDocumentDiagnosticReport
{
    /*
    Diagnostics of related documents. This information is useful
    in programming languages where code in a file A can generate
    diagnostics in a file B which A depends on. An example of
    such a language is C/C++ where marco definitions in a file
    a.cpp and result in errors in a header file b.hpp.

    @since 3.17.0
    */
    std::optional<std::map<DocumentUri, std::variant<FullDocumentDiagnosticReport, UnchangedDocumentDiagnosticReport>>>
        relatedDocuments;
};

struct WorkspaceFullDocumentDiagnosticReport : public FullDocumentDiagnosticReport
{
    // The URI for which diagnostic information is reported.
    DocumentUri uri;
    /*
    The version number for which the diagnostics are reported.
    If the document is not marked as open `null` can be provided.
    */
    std::variant<int, std::nullptr_t> version;
};

/*
A workspace diagnostic document report.

@since 3.17.0
*/
using WorkspaceDocumentDiagnosticReport =
    std::variant<WorkspaceFullDocumentDiagnosticReport, WorkspaceUnchangedDocumentDiagnosticReport>;

/*
The result of a document diagnostic pull request. A report can
either be a full report containing all diagnostics for the
requested document or an unchanged report indicating that nothing
has changed in terms of diagnostics in comparison to the last
pull request.

@since 3.17.0
*/
using DocumentDiagnosticReport =
    std::variant<RelatedFullDocumentDiagnosticReport, RelatedUnchangedDocumentDiagnosticReport>;

struct ServerCapabilities
{
    struct WorkspaceType
    {
        /*
        The server supports workspace folder.

        @since 3.6.0
        */
        std::optional<WorkspaceFoldersServerCapabilities> workspaceFolders;
        /*
        The server is interested in notifications/requests for operations on files.

        @since 3.16.0
        */
        std::optional<FileOperationOptions> fileOperations;
    };
    /*
    The position encoding the server picked from the encodings offered
    by the client via the client capability `general.positionEncodings`.

    If the client didn't provide any position encodings the only valid
    value that a server can return is 'utf-16'.

    If omitted it defaults to 'utf-16'.

    @since 3.17.0
    */
    std::optional<PositionEncodingKind> positionEncoding;
    /*
    Defines how text documents are synced. Is either a detailed structure
    defining each notification or for backwards compatibility the
    TextDocumentSyncKind number.
    */
    std::optional<std::variant<TextDocumentSyncOptions, TextDocumentSyncKind>> textDocumentSync;
    /*
    Defines how notebook documents are synced.

    @since 3.17.0
    */
    std::optional<std::variant<NotebookDocumentSyncOptions, NotebookDocumentSyncRegistrationOptions>>
        notebookDocumentSync;
    // The server provides completion support.
    std::optional<CompletionOptions> completionProvider;
    // The server provides hover support.
    std::optional<std::variant<bool, HoverOptions>> hoverProvider;
    // The server provides signature help support.
    std::optional<SignatureHelpOptions> signatureHelpProvider;
    // The server provides Goto Declaration support.
    std::optional<std::variant<bool, DeclarationOptions, DeclarationRegistrationOptions>> declarationProvider;
    // The server provides goto definition support.
    std::optional<std::variant<bool, DefinitionOptions>> definitionProvider;
    // The server provides Goto Type Definition support.
    std::optional<std::variant<bool, TypeDefinitionOptions, TypeDefinitionRegistrationOptions>> typeDefinitionProvider;
    // The server provides Goto Implementation support.
    std::optional<std::variant<bool, ImplementationOptions, ImplementationRegistrationOptions>> implementationProvider;
    // The server provides find references support.
    std::optional<std::variant<bool, ReferenceOptions>> referencesProvider;
    // The server provides document highlight support.
    std::optional<std::variant<bool, DocumentHighlightOptions>> documentHighlightProvider;
    // The server provides document symbol support.
    std::optional<std::variant<bool, DocumentSymbolOptions>> documentSymbolProvider;
    /*
    The server provides code actions. CodeActionOptions may only be
    specified if the client states that it supports
    `codeActionLiteralSupport` in its initial `initialize` request.
    */
    std::optional<std::variant<bool, CodeActionOptions>> codeActionProvider;
    // The server provides code lens.
    std::optional<CodeLensOptions> codeLensProvider;
    // The server provides document link support.
    std::optional<DocumentLinkOptions> documentLinkProvider;
    // The server provides color provider support.
    std::optional<std::variant<bool, DocumentColorOptions, DocumentColorRegistrationOptions>> colorProvider;
    // The server provides workspace symbol support.
    std::optional<std::variant<bool, WorkspaceSymbolOptions>> workspaceSymbolProvider;
    // The server provides document formatting.
    std::optional<std::variant<bool, DocumentFormattingOptions>> documentFormattingProvider;
    // The server provides document range formatting.
    std::optional<std::variant<bool, DocumentRangeFormattingOptions>> documentRangeFormattingProvider;
    // The server provides document formatting on typing.
    std::optional<DocumentOnTypeFormattingOptions> documentOnTypeFormattingProvider;
    /*
    The server provides rename support. RenameOptions may only be
    specified if the client states that it supports
    `prepareSupport` in its initial `initialize` request.
    */
    std::optional<std::variant<bool, RenameOptions>> renameProvider;
    // The server provides folding provider support.
    std::optional<std::variant<bool, FoldingRangeOptions, FoldingRangeRegistrationOptions>> foldingRangeProvider;
    // The server provides selection range support.
    std::optional<std::variant<bool, SelectionRangeOptions, SelectionRangeRegistrationOptions>> selectionRangeProvider;
    // The server provides execute command support.
    std::optional<ExecuteCommandOptions> executeCommandProvider;
    /*
    The server provides call hierarchy support.

    @since 3.16.0
    */
    std::optional<std::variant<bool, CallHierarchyOptions, CallHierarchyRegistrationOptions>> callHierarchyProvider;
    /*
    The server provides linked editing range support.

    @since 3.16.0
    */
    std::optional<std::variant<bool, LinkedEditingRangeOptions, LinkedEditingRangeRegistrationOptions>>
        linkedEditingRangeProvider;
    /*
    The server provides semantic tokens support.

    @since 3.16.0
    */
    std::optional<std::variant<SemanticTokensOptions, SemanticTokensRegistrationOptions>> semanticTokensProvider;
    /*
    The server provides moniker support.

    @since 3.16.0
    */
    std::optional<std::variant<bool, MonikerOptions, MonikerRegistrationOptions>> monikerProvider;
    /*
    The server provides type hierarchy support.

    @since 3.17.0
    */
    std::optional<std::variant<bool, TypeHierarchyOptions, TypeHierarchyRegistrationOptions>> typeHierarchyProvider;
    /*
    The server provides inline values.

    @since 3.17.0
    */
    std::optional<std::variant<bool, InlineValueOptions, InlineValueRegistrationOptions>> inlineValueProvider;
    /*
    The server provides inlay hints.

    @since 3.17.0
    */
    std::optional<std::variant<bool, InlayHintOptions, InlayHintRegistrationOptions>> inlayHintProvider;
    /*
    The server has support for pull model diagnostics.

    @since 3.17.0
    */
    std::optional<std::variant<DiagnosticOptions, DiagnosticRegistrationOptions>> diagnosticProvider;
    // Workspace specific server capabilities.
    std::optional<WorkspaceType> workspace;
    // Experimental server capabilities.
    std::optional<nlohmann::json> experimental;
};

struct InitializeResult
{
    struct ServerInfoType
    {
        // The name of the server as defined by the server.
        std::string name;
        // The server's version as defined by the server.
        std::optional<std::string> version;
    };
    // The capabilities the language server provides.
    ServerCapabilities capabilities;
    /*
    Information about the server.

    @since 3.15.0
    */
    std::optional<ServerInfoType> serverInfo;
};

struct WorkspaceDiagnosticReportPartialResult
{
    std::vector<WorkspaceDocumentDiagnosticReport> items;
};

struct WorkspaceDiagnosticReport
{
    std::vector<WorkspaceDocumentDiagnosticReport> items;
};

}
